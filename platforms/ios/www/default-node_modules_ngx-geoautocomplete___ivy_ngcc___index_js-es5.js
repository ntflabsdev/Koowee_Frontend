(function () {
  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

  function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

  function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  (self["webpackChunkkoowee"] = self["webpackChunkkoowee"] || []).push([["default-node_modules_ngx-geoautocomplete___ivy_ngcc___index_js"], {
    /***/
    91841: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "HTTP_INTERCEPTORS": function HTTP_INTERCEPTORS() {
          return (
            /* binding */
            _HTTP_INTERCEPTORS
          );
        },

        /* harmony export */
        "HttpBackend": function HttpBackend() {
          return (
            /* binding */
            _HttpBackend
          );
        },

        /* harmony export */
        "HttpClient": function HttpClient() {
          return (
            /* binding */
            _HttpClient
          );
        },

        /* harmony export */
        "HttpClientJsonpModule": function HttpClientJsonpModule() {
          return (
            /* binding */
            _HttpClientJsonpModule
          );
        },

        /* harmony export */
        "HttpClientModule": function HttpClientModule() {
          return (
            /* binding */
            _HttpClientModule
          );
        },

        /* harmony export */
        "HttpClientXsrfModule": function HttpClientXsrfModule() {
          return (
            /* binding */
            _HttpClientXsrfModule
          );
        },

        /* harmony export */
        "HttpContext": function HttpContext() {
          return (
            /* binding */
            _HttpContext
          );
        },

        /* harmony export */
        "HttpContextToken": function HttpContextToken() {
          return (
            /* binding */
            _HttpContextToken
          );
        },

        /* harmony export */
        "HttpErrorResponse": function HttpErrorResponse() {
          return (
            /* binding */
            _HttpErrorResponse
          );
        },

        /* harmony export */
        "HttpEventType": function HttpEventType() {
          return (
            /* binding */
            _HttpEventType
          );
        },

        /* harmony export */
        "HttpHandler": function HttpHandler() {
          return (
            /* binding */
            _HttpHandler
          );
        },

        /* harmony export */
        "HttpHeaderResponse": function HttpHeaderResponse() {
          return (
            /* binding */
            _HttpHeaderResponse
          );
        },

        /* harmony export */
        "HttpHeaders": function HttpHeaders() {
          return (
            /* binding */
            _HttpHeaders
          );
        },

        /* harmony export */
        "HttpParams": function HttpParams() {
          return (
            /* binding */
            _HttpParams
          );
        },

        /* harmony export */
        "HttpRequest": function HttpRequest() {
          return (
            /* binding */
            _HttpRequest
          );
        },

        /* harmony export */
        "HttpResponse": function HttpResponse() {
          return (
            /* binding */
            _HttpResponse
          );
        },

        /* harmony export */
        "HttpResponseBase": function HttpResponseBase() {
          return (
            /* binding */
            _HttpResponseBase
          );
        },

        /* harmony export */
        "HttpUrlEncodingCodec": function HttpUrlEncodingCodec() {
          return (
            /* binding */
            _HttpUrlEncodingCodec
          );
        },

        /* harmony export */
        "HttpXhrBackend": function HttpXhrBackend() {
          return (
            /* binding */
            _HttpXhrBackend
          );
        },

        /* harmony export */
        "HttpXsrfTokenExtractor": function HttpXsrfTokenExtractor() {
          return (
            /* binding */
            _HttpXsrfTokenExtractor
          );
        },

        /* harmony export */
        "JsonpClientBackend": function JsonpClientBackend() {
          return (
            /* binding */
            _JsonpClientBackend
          );
        },

        /* harmony export */
        "JsonpInterceptor": function JsonpInterceptor() {
          return (
            /* binding */
            _JsonpInterceptor
          );
        },

        /* harmony export */
        "XhrFactory": function XhrFactory() {
          return (
            /* binding */
            _XhrFactory
          );
        },

        /* harmony export */
        "ɵHttpInterceptingHandler": function ɵHttpInterceptingHandler() {
          return (
            /* binding */
            HttpInterceptingHandler
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_a": function ɵangular_packages_common_http_http_a() {
          return (
            /* binding */
            NoopInterceptor
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_b": function ɵangular_packages_common_http_http_b() {
          return (
            /* binding */
            JsonpCallbackContext
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_c": function ɵangular_packages_common_http_http_c() {
          return (
            /* binding */
            jsonpCallbackContext
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_d": function ɵangular_packages_common_http_http_d() {
          return (
            /* binding */
            XSRF_COOKIE_NAME
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_e": function ɵangular_packages_common_http_http_e() {
          return (
            /* binding */
            XSRF_HEADER_NAME
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_f": function ɵangular_packages_common_http_http_f() {
          return (
            /* binding */
            HttpXsrfCookieExtractor
          );
        },

        /* harmony export */
        "ɵangular_packages_common_http_http_g": function ɵangular_packages_common_http_http_g() {
          return (
            /* binding */
            HttpXsrfInterceptor
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! @angular/common */
      38583);
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! rxjs */
      25917);
      /* harmony import */


      var rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! rxjs */
      69165);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! rxjs/operators */
      94612);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! rxjs/operators */
      45435);
      /* harmony import */


      var rxjs_operators__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! rxjs/operators */
      88002);
      /**
       * @license Angular v12.0.5
       * (c) 2010-2021 Google LLC. https://angular.io/
       * License: MIT
       */

      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
       * `HttpResponse`.
       *
       * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
       * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
       * `HttpBackend`.
       *
       * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
       *
       * @publicApi
       */


      var _HttpHandler = function _HttpHandler() {
        _classCallCheck(this, _HttpHandler);
      };
      /**
       * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
       *
       * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
       *
       * When injected, `HttpBackend` dispatches requests directly to the backend, without going
       * through the interceptor chain.
       *
       * @publicApi
       */


      var _HttpBackend = function _HttpBackend() {
        _classCallCheck(this, _HttpBackend);
      };
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Represents the header configuration options for an HTTP request.
       * Instances are immutable. Modifying methods return a cloned
       * instance with the change. The original object is never changed.
       *
       * @publicApi
       */


      var _HttpHeaders = /*#__PURE__*/function () {
        /**  Constructs a new HTTP header object with the given values.*/
        function _HttpHeaders(headers) {
          var _this2 = this;

          _classCallCheck(this, _HttpHeaders);

          /**
           * Internal map of lowercased header names to the normalized
           * form of the name (the form seen first).
           */
          this.normalizedNames = new Map();
          /**
           * Queued updates to be materialized the next initialization.
           */

          this.lazyUpdate = null;

          if (!headers) {
            this.headers = new Map();
          } else if (typeof headers === 'string') {
            this.lazyInit = function () {
              _this2.headers = new Map();
              headers.split('\n').forEach(function (line) {
                var index = line.indexOf(':');

                if (index > 0) {
                  var name = line.slice(0, index);
                  var key = name.toLowerCase();
                  var value = line.slice(index + 1).trim();

                  _this2.maybeSetNormalizedName(name, key);

                  if (_this2.headers.has(key)) {
                    _this2.headers.get(key).push(value);
                  } else {
                    _this2.headers.set(key, [value]);
                  }
                }
              });
            };
          } else {
            this.lazyInit = function () {
              _this2.headers = new Map();
              Object.keys(headers).forEach(function (name) {
                var values = headers[name];
                var key = name.toLowerCase();

                if (typeof values === 'string') {
                  values = [values];
                }

                if (values.length > 0) {
                  _this2.headers.set(key, values);

                  _this2.maybeSetNormalizedName(name, key);
                }
              });
            };
          }
        }
        /**
         * Checks for existence of a given header.
         *
         * @param name The header name to check for existence.
         *
         * @returns True if the header exists, false otherwise.
         */


        _createClass(_HttpHeaders, [{
          key: "has",
          value: function has(name) {
            this.init();
            return this.headers.has(name.toLowerCase());
          }
          /**
           * Retrieves the first value of a given header.
           *
           * @param name The header name.
           *
           * @returns The value string if the header exists, null otherwise
           */

        }, {
          key: "get",
          value: function get(name) {
            this.init();
            var values = this.headers.get(name.toLowerCase());
            return values && values.length > 0 ? values[0] : null;
          }
          /**
           * Retrieves the names of the headers.
           *
           * @returns A list of header names.
           */

        }, {
          key: "keys",
          value: function keys() {
            this.init();
            return Array.from(this.normalizedNames.values());
          }
          /**
           * Retrieves a list of values for a given header.
           *
           * @param name The header name from which to retrieve values.
           *
           * @returns A string of values if the header exists, null otherwise.
           */

        }, {
          key: "getAll",
          value: function getAll(name) {
            this.init();
            return this.headers.get(name.toLowerCase()) || null;
          }
          /**
           * Appends a new value to the existing set of values for a header
           * and returns them in a clone of the original instance.
           *
           * @param name The header name for which to append the values.
           * @param value The value to append.
           *
           * @returns A clone of the HTTP headers object with the value appended to the given header.
           */

        }, {
          key: "append",
          value: function append(name, value) {
            return this.clone({
              name: name,
              value: value,
              op: 'a'
            });
          }
          /**
           * Sets or modifies a value for a given header in a clone of the original instance.
           * If the header already exists, its value is replaced with the given value
           * in the returned object.
           *
           * @param name The header name.
           * @param value The value or values to set or overide for the given header.
           *
           * @returns A clone of the HTTP headers object with the newly set header value.
           */

        }, {
          key: "set",
          value: function set(name, value) {
            return this.clone({
              name: name,
              value: value,
              op: 's'
            });
          }
          /**
           * Deletes values for a given header in a clone of the original instance.
           *
           * @param name The header name.
           * @param value The value or values to delete for the given header.
           *
           * @returns A clone of the HTTP headers object with the given value deleted.
           */

        }, {
          key: "delete",
          value: function _delete(name, value) {
            return this.clone({
              name: name,
              value: value,
              op: 'd'
            });
          }
        }, {
          key: "maybeSetNormalizedName",
          value: function maybeSetNormalizedName(name, lcName) {
            if (!this.normalizedNames.has(lcName)) {
              this.normalizedNames.set(lcName, name);
            }
          }
        }, {
          key: "init",
          value: function init() {
            var _this3 = this;

            if (!!this.lazyInit) {
              if (this.lazyInit instanceof _HttpHeaders) {
                this.copyFrom(this.lazyInit);
              } else {
                this.lazyInit();
              }

              this.lazyInit = null;

              if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) {
                  return _this3.applyUpdate(update);
                });
                this.lazyUpdate = null;
              }
            }
          }
        }, {
          key: "copyFrom",
          value: function copyFrom(other) {
            var _this4 = this;

            other.init();
            Array.from(other.headers.keys()).forEach(function (key) {
              _this4.headers.set(key, other.headers.get(key));

              _this4.normalizedNames.set(key, other.normalizedNames.get(key));
            });
          }
        }, {
          key: "clone",
          value: function clone(update) {
            var clone = new _HttpHeaders();
            clone.lazyInit = !!this.lazyInit && this.lazyInit instanceof _HttpHeaders ? this.lazyInit : this;
            clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
            return clone;
          }
        }, {
          key: "applyUpdate",
          value: function applyUpdate(update) {
            var key = update.name.toLowerCase();

            switch (update.op) {
              case 'a':
              case 's':
                var value = update.value;

                if (typeof value === 'string') {
                  value = [value];
                }

                if (value.length === 0) {
                  return;
                }

                this.maybeSetNormalizedName(update.name, key);
                var base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, _toConsumableArray(value));
                this.headers.set(key, base);
                break;

              case 'd':
                var toDelete = update.value;

                if (!toDelete) {
                  this.headers["delete"](key);
                  this.normalizedNames["delete"](key);
                } else {
                  var existing = this.headers.get(key);

                  if (!existing) {
                    return;
                  }

                  existing = existing.filter(function (value) {
                    return toDelete.indexOf(value) === -1;
                  });

                  if (existing.length === 0) {
                    this.headers["delete"](key);
                    this.normalizedNames["delete"](key);
                  } else {
                    this.headers.set(key, existing);
                  }
                }

                break;
            }
          }
          /**
           * @internal
           */

        }, {
          key: "forEach",
          value: function forEach(fn) {
            var _this5 = this;

            this.init();
            Array.from(this.normalizedNames.keys()).forEach(function (key) {
              return fn(_this5.normalizedNames.get(key), _this5.headers.get(key));
            });
          }
        }]);

        return _HttpHeaders;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Provides encoding and decoding of URL parameter and query-string values.
       *
       * Serializes and parses URL parameter keys and values to encode and decode them.
       * If you pass URL query parameters without encoding,
       * the query parameters can be misinterpreted at the receiving end.
       *
       *
       * @publicApi
       */


      var _HttpUrlEncodingCodec = /*#__PURE__*/function () {
        function _HttpUrlEncodingCodec() {
          _classCallCheck(this, _HttpUrlEncodingCodec);
        }

        _createClass(_HttpUrlEncodingCodec, [{
          key: "encodeKey",
          value:
          /**
           * Encodes a key name for a URL parameter or query-string.
           * @param key The key name.
           * @returns The encoded key name.
           */
          function encodeKey(key) {
            return standardEncoding(key);
          }
          /**
           * Encodes the value of a URL parameter or query-string.
           * @param value The value.
           * @returns The encoded value.
           */

        }, {
          key: "encodeValue",
          value: function encodeValue(value) {
            return standardEncoding(value);
          }
          /**
           * Decodes an encoded URL parameter or query-string key.
           * @param key The encoded key name.
           * @returns The decoded key name.
           */

        }, {
          key: "decodeKey",
          value: function decodeKey(key) {
            return decodeURIComponent(key);
          }
          /**
           * Decodes an encoded URL parameter or query-string value.
           * @param value The encoded value.
           * @returns The decoded value.
           */

        }, {
          key: "decodeValue",
          value: function decodeValue(value) {
            return decodeURIComponent(value);
          }
        }]);

        return _HttpUrlEncodingCodec;
      }();

      function paramParser(rawParams, codec) {
        var map = new Map();

        if (rawParams.length > 0) {
          // The `window.location.search` can be used while creating an instance of the `HttpParams` class
          // (e.g. `new HttpParams({ fromString: window.location.search })`). The `window.location.search`
          // may start with the `?` char, so we strip it if it's present.
          var params = rawParams.replace(/^\?/, '').split('&');
          params.forEach(function (param) {
            var eqIdx = param.indexOf('=');

            var _ref = eqIdx == -1 ? [codec.decodeKey(param), ''] : [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))],
                _ref2 = _slicedToArray(_ref, 2),
                key = _ref2[0],
                val = _ref2[1];

            var list = map.get(key) || [];
            list.push(val);
            map.set(key, list);
          });
        }

        return map;
      }

      function standardEncoding(v) {
        return encodeURIComponent(v).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/gi, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%2B/gi, '+').replace(/%3D/gi, '=').replace(/%3F/gi, '?').replace(/%2F/gi, '/');
      }

      function valueToString(value) {
        return "".concat(value);
      }
      /**
       * An HTTP request/response body that represents serialized parameters,
       * per the MIME type `application/x-www-form-urlencoded`.
       *
       * This class is immutable; all mutation operations return a new instance.
       *
       * @publicApi
       */


      var _HttpParams = /*#__PURE__*/function () {
        function _HttpParams() {
          var _this6 = this;

          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, _HttpParams);

          this.updates = null;
          this.cloneFrom = null;
          this.encoder = options.encoder || new _HttpUrlEncodingCodec();

          if (!!options.fromString) {
            if (!!options.fromObject) {
              throw new Error("Cannot specify both fromString and fromObject.");
            }

            this.map = paramParser(options.fromString, this.encoder);
          } else if (!!options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach(function (key) {
              var value = options.fromObject[key];

              _this6.map.set(key, Array.isArray(value) ? value : [value]);
            });
          } else {
            this.map = null;
          }
        }
        /**
         * Reports whether the body includes one or more values for a given parameter.
         * @param param The parameter name.
         * @returns True if the parameter has one or more values,
         * false if it has no value or is not present.
         */


        _createClass(_HttpParams, [{
          key: "has",
          value: function has(param) {
            this.init();
            return this.map.has(param);
          }
          /**
           * Retrieves the first value for a parameter.
           * @param param The parameter name.
           * @returns The first value of the given parameter,
           * or `null` if the parameter is not present.
           */

        }, {
          key: "get",
          value: function get(param) {
            this.init();
            var res = this.map.get(param);
            return !!res ? res[0] : null;
          }
          /**
           * Retrieves all values for a  parameter.
           * @param param The parameter name.
           * @returns All values in a string array,
           * or `null` if the parameter not present.
           */

        }, {
          key: "getAll",
          value: function getAll(param) {
            this.init();
            return this.map.get(param) || null;
          }
          /**
           * Retrieves all the parameters for this body.
           * @returns The parameter names in a string array.
           */

        }, {
          key: "keys",
          value: function keys() {
            this.init();
            return Array.from(this.map.keys());
          }
          /**
           * Appends a new value to existing values for a parameter.
           * @param param The parameter name.
           * @param value The new value to add.
           * @return A new body with the appended value.
           */

        }, {
          key: "append",
          value: function append(param, value) {
            return this.clone({
              param: param,
              value: value,
              op: 'a'
            });
          }
          /**
           * Constructs a new body with appended values for the given parameter name.
           * @param params parameters and values
           * @return A new body with the new value.
           */

        }, {
          key: "appendAll",
          value: function appendAll(params) {
            var updates = [];
            Object.keys(params).forEach(function (param) {
              var value = params[param];

              if (Array.isArray(value)) {
                value.forEach(function (_value) {
                  updates.push({
                    param: param,
                    value: _value,
                    op: 'a'
                  });
                });
              } else {
                updates.push({
                  param: param,
                  value: value,
                  op: 'a'
                });
              }
            });
            return this.clone(updates);
          }
          /**
           * Replaces the value for a parameter.
           * @param param The parameter name.
           * @param value The new value.
           * @return A new body with the new value.
           */

        }, {
          key: "set",
          value: function set(param, value) {
            return this.clone({
              param: param,
              value: value,
              op: 's'
            });
          }
          /**
           * Removes a given value or all values from a parameter.
           * @param param The parameter name.
           * @param value The value to remove, if provided.
           * @return A new body with the given value removed, or with all values
           * removed if no value is specified.
           */

        }, {
          key: "delete",
          value: function _delete(param, value) {
            return this.clone({
              param: param,
              value: value,
              op: 'd'
            });
          }
          /**
           * Serializes the body to an encoded string, where key-value pairs (separated by `=`) are
           * separated by `&`s.
           */

        }, {
          key: "toString",
          value: function toString() {
            var _this7 = this;

            this.init();
            return this.keys().map(function (key) {
              var eKey = _this7.encoder.encodeKey(key); // `a: ['1']` produces `'a=1'`
              // `b: []` produces `''`
              // `c: ['1', '2']` produces `'c=1&c=2'`


              return _this7.map.get(key).map(function (value) {
                return eKey + '=' + _this7.encoder.encodeValue(value);
              }).join('&');
            }) // filter out empty values because `b: []` produces `''`
            // which results in `a=1&&c=1&c=2` instead of `a=1&c=1&c=2` if we don't
            .filter(function (param) {
              return param !== '';
            }).join('&');
          }
        }, {
          key: "clone",
          value: function clone(update) {
            var clone = new _HttpParams({
              encoder: this.encoder
            });
            clone.cloneFrom = this.cloneFrom || this;
            clone.updates = (this.updates || []).concat(update);
            return clone;
          }
        }, {
          key: "init",
          value: function init() {
            var _this8 = this;

            if (this.map === null) {
              this.map = new Map();
            }

            if (this.cloneFrom !== null) {
              this.cloneFrom.init();
              this.cloneFrom.keys().forEach(function (key) {
                return _this8.map.set(key, _this8.cloneFrom.map.get(key));
              });
              this.updates.forEach(function (update) {
                switch (update.op) {
                  case 'a':
                  case 's':
                    var base = (update.op === 'a' ? _this8.map.get(update.param) : undefined) || [];
                    base.push(valueToString(update.value));

                    _this8.map.set(update.param, base);

                    break;

                  case 'd':
                    if (update.value !== undefined) {
                      var _base = _this8.map.get(update.param) || [];

                      var idx = _base.indexOf(valueToString(update.value));

                      if (idx !== -1) {
                        _base.splice(idx, 1);
                      }

                      if (_base.length > 0) {
                        _this8.map.set(update.param, _base);
                      } else {
                        _this8.map["delete"](update.param);
                      }
                    } else {
                      _this8.map["delete"](update.param);

                      break;
                    }

                }
              });
              this.cloneFrom = this.updates = null;
            }
          }
        }]);

        return _HttpParams;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * A token used to manipulate and access values stored in `HttpContext`.
       *
       * @publicApi
       */


      var _HttpContextToken = function _HttpContextToken(defaultValue) {
        _classCallCheck(this, _HttpContextToken);

        this.defaultValue = defaultValue;
      };
      /**
       * Http context stores arbitrary user defined values and ensures type safety without
       * actually knowing the types. It is backed by a `Map` and guarantees that keys do not clash.
       *
       * This context is mutable and is shared between cloned requests unless explicitly specified.
       *
       * @usageNotes
       *
       * ### Usage Example
       *
       * ```typescript
       * // inside cache.interceptors.ts
       * export const IS_CACHE_ENABLED = new HttpContextToken<boolean>(() => false);
       *
       * export class CacheInterceptor implements HttpInterceptor {
       *
       *   intercept(req: HttpRequest<any>, delegate: HttpHandler): Observable<HttpEvent<any>> {
       *     if (req.context.get(IS_CACHE_ENABLED) === true) {
       *       return ...;
       *     }
       *     return delegate.handle(req);
       *   }
       * }
       *
       * // inside a service
       *
       * this.httpClient.get('/api/weather', {
       *   context: new HttpContext().set(IS_CACHE_ENABLED, true)
       * }).subscribe(...);
       * ```
       *
       * @publicApi
       */


      var _HttpContext = /*#__PURE__*/function () {
        function _HttpContext() {
          _classCallCheck(this, _HttpContext);

          this.map = new Map();
        }
        /**
         * Store a value in the context. If a value is already present it will be overwritten.
         *
         * @param token The reference to an instance of `HttpContextToken`.
         * @param value The value to store.
         *
         * @returns A reference to itself for easy chaining.
         */


        _createClass(_HttpContext, [{
          key: "set",
          value: function set(token, value) {
            this.map.set(token, value);
            return this;
          }
          /**
           * Retrieve the value associated with the given token.
           *
           * @param token The reference to an instance of `HttpContextToken`.
           *
           * @returns The stored value or default if one is defined.
           */

        }, {
          key: "get",
          value: function get(token) {
            if (!this.map.has(token)) {
              this.map.set(token, token.defaultValue());
            }

            return this.map.get(token);
          }
          /**
           * Delete the value associated with the given token.
           *
           * @param token The reference to an instance of `HttpContextToken`.
           *
           * @returns A reference to itself for easy chaining.
           */

        }, {
          key: "delete",
          value: function _delete(token) {
            this.map["delete"](token);
            return this;
          }
          /**
           * @returns a list of tokens currently stored in the context.
           */

        }, {
          key: "keys",
          value: function keys() {
            return this.map.keys();
          }
        }]);

        return _HttpContext;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Determine whether the given HTTP method may include a body.
       */


      function mightHaveBody(method) {
        switch (method) {
          case 'DELETE':
          case 'GET':
          case 'HEAD':
          case 'OPTIONS':
          case 'JSONP':
            return false;

          default:
            return true;
        }
      }
      /**
       * Safely assert whether the given value is an ArrayBuffer.
       *
       * In some execution environments ArrayBuffer is not defined.
       */


      function isArrayBuffer(value) {
        return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
      }
      /**
       * Safely assert whether the given value is a Blob.
       *
       * In some execution environments Blob is not defined.
       */


      function isBlob(value) {
        return typeof Blob !== 'undefined' && value instanceof Blob;
      }
      /**
       * Safely assert whether the given value is a FormData instance.
       *
       * In some execution environments FormData is not defined.
       */


      function isFormData(value) {
        return typeof FormData !== 'undefined' && value instanceof FormData;
      }
      /**
       * An outgoing HTTP request with an optional typed body.
       *
       * `HttpRequest` represents an outgoing request, including URL, method,
       * headers, body, and other request configuration options. Instances should be
       * assumed to be immutable. To modify a `HttpRequest`, the `clone`
       * method should be used.
       *
       * @publicApi
       */


      var _HttpRequest = /*#__PURE__*/function () {
        function _HttpRequest(method, url, third, fourth) {
          _classCallCheck(this, _HttpRequest);

          this.url = url;
          /**
           * The request body, or `null` if one isn't set.
           *
           * Bodies are not enforced to be immutable, as they can include a reference to any
           * user-defined data type. However, interceptors should take care to preserve
           * idempotence by treating them as such.
           */

          this.body = null;
          /**
           * Whether this request should be made in a way that exposes progress events.
           *
           * Progress events are expensive (change detection runs on each event) and so
           * they should only be requested if the consumer intends to monitor them.
           */

          this.reportProgress = false;
          /**
           * Whether this request should be sent with outgoing credentials (cookies).
           */

          this.withCredentials = false;
          /**
           * The expected response type of the server.
           *
           * This is used to parse the response appropriately before returning it to
           * the requestee.
           */

          this.responseType = 'json';
          this.method = method.toUpperCase(); // Next, need to figure out which argument holds the HttpRequestInit
          // options, if any.

          var options; // Check whether a body argument is expected. The only valid way to omit
          // the body argument is to use a known no-body method like GET.

          if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = third !== undefined ? third : null;
            options = fourth;
          } else {
            // No body required, options are the third argument. The body stays null.
            options = third;
          } // If options have been passed, interpret them.


          if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials; // Override default response type of 'json' if one is provided.

            if (!!options.responseType) {
              this.responseType = options.responseType;
            } // Override headers if they're provided.


            if (!!options.headers) {
              this.headers = options.headers;
            }

            if (!!options.context) {
              this.context = options.context;
            }

            if (!!options.params) {
              this.params = options.params;
            }
          } // If no headers have been passed in, construct a new HttpHeaders instance.


          if (!this.headers) {
            this.headers = new _HttpHeaders();
          } // If no context have been passed in, construct a new HttpContext instance.


          if (!this.context) {
            this.context = new _HttpContext();
          } // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.


          if (!this.params) {
            this.params = new _HttpParams();
            this.urlWithParams = url;
          } else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var params = this.params.toString();

            if (params.length === 0) {
              // No parameters, the visible URL is just the URL given at creation time.
              this.urlWithParams = url;
            } else {
              // Does the URL already have query parameters? Look for '?'.
              var qIdx = url.indexOf('?'); // There are 3 cases to handle:
              // 1) No existing parameters -> append '?' followed by params.
              // 2) '?' exists and is followed by existing query string ->
              //    append '&' followed by params.
              // 3) '?' exists at the end of the url -> append params directly.
              // This basically amounts to determining the character, if any, with
              // which to join the URL and parameters.

              var sep = qIdx === -1 ? '?' : qIdx < url.length - 1 ? '&' : '';
              this.urlWithParams = url + sep + params;
            }
          }
        }
        /**
         * Transform the free-form body into a serialized format suitable for
         * transmission to the server.
         */


        _createClass(_HttpRequest, [{
          key: "serializeBody",
          value: function serializeBody() {
            // If no body is present, no need to serialize it.
            if (this.body === null) {
              return null;
            } // Check whether the body is already in a serialized form. If so,
            // it can just be returned directly.


            if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) || typeof this.body === 'string') {
              return this.body;
            } // Check whether the body is an instance of HttpUrlEncodedParams.


            if (this.body instanceof _HttpParams) {
              return this.body.toString();
            } // Check whether the body is an object or array, and serialize with JSON if so.


            if (typeof this.body === 'object' || typeof this.body === 'boolean' || Array.isArray(this.body)) {
              return JSON.stringify(this.body);
            } // Fall back on toString() for everything else.


            return this.body.toString();
          }
          /**
           * Examine the body and attempt to infer an appropriate MIME type
           * for it.
           *
           * If no such type can be inferred, this method will return `null`.
           */

        }, {
          key: "detectContentTypeHeader",
          value: function detectContentTypeHeader() {
            // An empty body has no content type.
            if (this.body === null) {
              return null;
            } // FormData bodies rely on the browser's content type assignment.


            if (isFormData(this.body)) {
              return null;
            } // Blobs usually have their own content type. If it doesn't, then
            // no type can be inferred.


            if (isBlob(this.body)) {
              return this.body.type || null;
            } // Array buffers have unknown contents and thus no type can be inferred.


            if (isArrayBuffer(this.body)) {
              return null;
            } // Technically, strings could be a form of JSON data, but it's safe enough
            // to assume they're plain strings.


            if (typeof this.body === 'string') {
              return 'text/plain';
            } // `HttpUrlEncodedParams` has its own content-type.


            if (this.body instanceof _HttpParams) {
              return 'application/x-www-form-urlencoded;charset=UTF-8';
            } // Arrays, objects, boolean and numbers will be encoded as JSON.


            if (typeof this.body === 'object' || typeof this.body === 'number' || typeof this.body === 'boolean') {
              return 'application/json';
            } // No type could be inferred.


            return null;
          }
        }, {
          key: "clone",
          value: function clone() {
            var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

            var _a; // For method, url, and responseType, take the current value unless
            // it is overridden in the update hash.


            var method = update.method || this.method;
            var url = update.url || this.url;
            var responseType = update.responseType || this.responseType; // The body is somewhat special - a `null` value in update.body means
            // whatever current body is present is being overridden with an empty
            // body, whereas an `undefined` value in update.body implies no
            // override.

            var body = update.body !== undefined ? update.body : this.body; // Carefully handle the boolean options to differentiate between
            // `false` and `undefined` in the update args.

            var withCredentials = update.withCredentials !== undefined ? update.withCredentials : this.withCredentials;
            var reportProgress = update.reportProgress !== undefined ? update.reportProgress : this.reportProgress; // Headers and params may be appended to if `setHeaders` or
            // `setParams` are used.

            var headers = update.headers || this.headers;
            var params = update.params || this.params; // Pass on context if needed

            var context = (_a = update.context) !== null && _a !== void 0 ? _a : this.context; // Check whether the caller has asked to add headers.

            if (update.setHeaders !== undefined) {
              // Set every requested header.
              headers = Object.keys(update.setHeaders).reduce(function (headers, name) {
                return headers.set(name, update.setHeaders[name]);
              }, headers);
            } // Check whether the caller has asked to set params.


            if (update.setParams) {
              // Set every requested param.
              params = Object.keys(update.setParams).reduce(function (params, param) {
                return params.set(param, update.setParams[param]);
              }, params);
            } // Finally, construct the new HttpRequest using the pieces from above.


            return new _HttpRequest(method, url, body, {
              params: params,
              headers: headers,
              context: context,
              reportProgress: reportProgress,
              responseType: responseType,
              withCredentials: withCredentials
            });
          }
        }]);

        return _HttpRequest;
      }();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Type enumeration for the different kinds of `HttpEvent`.
       *
       * @publicApi
       */


      var _HttpEventType;

      (function (HttpEventType) {
        /**
         * The request was sent out over the wire.
         */
        HttpEventType[HttpEventType["Sent"] = 0] = "Sent";
        /**
         * An upload progress event was received.
         */

        HttpEventType[HttpEventType["UploadProgress"] = 1] = "UploadProgress";
        /**
         * The response status code and headers were received.
         */

        HttpEventType[HttpEventType["ResponseHeader"] = 2] = "ResponseHeader";
        /**
         * A download progress event was received.
         */

        HttpEventType[HttpEventType["DownloadProgress"] = 3] = "DownloadProgress";
        /**
         * The full response including the body was received.
         */

        HttpEventType[HttpEventType["Response"] = 4] = "Response";
        /**
         * A custom event from an interceptor or a backend.
         */

        HttpEventType[HttpEventType["User"] = 5] = "User";
      })(_HttpEventType || (_HttpEventType = {}));
      /**
       * Base class for both `HttpResponse` and `HttpHeaderResponse`.
       *
       * @publicApi
       */


      var _HttpResponseBase =
      /**
       * Super-constructor for all responses.
       *
       * The single parameter accepted is an initialization hash. Any properties
       * of the response passed there will override the default values.
       */
      function _HttpResponseBase(init) {
        var defaultStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;
        var defaultStatusText = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'OK';

        _classCallCheck(this, _HttpResponseBase);

        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new _HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null; // Cache the ok value to avoid defining a getter.

        this.ok = this.status >= 200 && this.status < 300;
      };
      /**
       * A partial HTTP response which only includes the status and header data,
       * but no response body.
       *
       * `HttpHeaderResponse` is a `HttpEvent` available on the response
       * event stream, only when progress events are requested.
       *
       * @publicApi
       */


      var _HttpHeaderResponse = /*#__PURE__*/function (_HttpResponseBase2) {
        _inherits(_HttpHeaderResponse, _HttpResponseBase2);

        var _super2 = _createSuper(_HttpHeaderResponse);

        /**
         * Create a new `HttpHeaderResponse` with the given parameters.
         */
        function _HttpHeaderResponse() {
          var _this9;

          var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, _HttpHeaderResponse);

          _this9 = _super2.call(this, init);
          _this9.type = _HttpEventType.ResponseHeader;
          return _this9;
        }
        /**
         * Copy this `HttpHeaderResponse`, overriding its contents with the
         * given parameter hash.
         */


        _createClass(_HttpHeaderResponse, [{
          key: "clone",
          value: function clone() {
            var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            // Perform a straightforward initialization of the new HttpHeaderResponse,
            // overriding the current parameters with new ones if given.
            return new _HttpHeaderResponse({
              headers: update.headers || this.headers,
              status: update.status !== undefined ? update.status : this.status,
              statusText: update.statusText || this.statusText,
              url: update.url || this.url || undefined
            });
          }
        }]);

        return _HttpHeaderResponse;
      }(_HttpResponseBase);
      /**
       * A full HTTP response, including a typed response body (which may be `null`
       * if one was not returned).
       *
       * `HttpResponse` is a `HttpEvent` available on the response event
       * stream.
       *
       * @publicApi
       */


      var _HttpResponse = /*#__PURE__*/function (_HttpResponseBase3) {
        _inherits(_HttpResponse, _HttpResponseBase3);

        var _super3 = _createSuper(_HttpResponse);

        /**
         * Construct a new `HttpResponse`.
         */
        function _HttpResponse() {
          var _this10;

          var init = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          _classCallCheck(this, _HttpResponse);

          _this10 = _super3.call(this, init);
          _this10.type = _HttpEventType.Response;
          _this10.body = init.body !== undefined ? init.body : null;
          return _this10;
        }

        _createClass(_HttpResponse, [{
          key: "clone",
          value: function clone() {
            var update = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return new _HttpResponse({
              body: update.body !== undefined ? update.body : this.body,
              headers: update.headers || this.headers,
              status: update.status !== undefined ? update.status : this.status,
              statusText: update.statusText || this.statusText,
              url: update.url || this.url || undefined
            });
          }
        }]);

        return _HttpResponse;
      }(_HttpResponseBase);
      /**
       * A response that represents an error or failure, either from a
       * non-successful HTTP status, an error while executing the request,
       * or some other failure which occurred during the parsing of the response.
       *
       * Any error returned on the `Observable` response stream will be
       * wrapped in an `HttpErrorResponse` to provide additional context about
       * the state of the HTTP layer when the error occurred. The error property
       * will contain either a wrapped Error object or the error response returned
       * from the server.
       *
       * @publicApi
       */


      var _HttpErrorResponse = /*#__PURE__*/function (_HttpResponseBase4) {
        _inherits(_HttpErrorResponse, _HttpResponseBase4);

        var _super4 = _createSuper(_HttpErrorResponse);

        function _HttpErrorResponse(init) {
          var _this11;

          _classCallCheck(this, _HttpErrorResponse);

          // Initialize with a default status of 0 / Unknown Error.
          _this11 = _super4.call(this, init, 0, 'Unknown Error');
          _this11.name = 'HttpErrorResponse';
          /**
           * Errors are never okay, even when the status code is in the 2xx success range.
           */

          _this11.ok = false; // If the response was successful, then this was a parse error. Otherwise, it was
          // a protocol-level failure of some sort. Either the request failed in transit
          // or the server returned an unsuccessful status code.

          if (_this11.status >= 200 && _this11.status < 300) {
            _this11.message = "Http failure during parsing for ".concat(init.url || '(unknown url)');
          } else {
            _this11.message = "Http failure response for ".concat(init.url || '(unknown url)', ": ").concat(init.status, " ").concat(init.statusText);
          }

          _this11.error = init.error || null;
          return _this11;
        }

        return _HttpErrorResponse;
      }(_HttpResponseBase);
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Constructs an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
       * the given `body`. This function clones the object and adds the body.
       *
       * Note that the `responseType` *options* value is a String that identifies the
       * single data type of the response.
       * A single overload version of the method handles each response type.
       * The value of `responseType` cannot be a union, as the combined signature could imply.
       *
       */


      function addBody(options, body) {
        return {
          body: body,
          headers: options.headers,
          context: options.context,
          observe: options.observe,
          params: options.params,
          reportProgress: options.reportProgress,
          responseType: options.responseType,
          withCredentials: options.withCredentials
        };
      }
      /**
       * Performs HTTP requests.
       * This service is available as an injectable class, with methods to perform HTTP requests.
       * Each request method has multiple signatures, and the return type varies based on
       * the signature that is called (mainly the values of `observe` and `responseType`).
       *
       * Note that the `responseType` *options* value is a String that identifies the
       * single data type of the response.
       * A single overload version of the method handles each response type.
       * The value of `responseType` cannot be a union, as the combined signature could imply.
      
       *
       * @usageNotes
       * Sample HTTP requests for the [Tour of Heroes](/tutorial/toh-pt0) application.
       *
       * ### HTTP Request Example
       *
       * ```
       *  // GET heroes whose name contains search term
       * searchHeroes(term: string): observable<Hero[]>{
       *
       *  const params = new HttpParams({fromString: 'name=term'});
       *    return this.httpClient.request('GET', this.heroesUrl, {responseType:'json', params});
       * }
       * ```
       *
       * Alternatively, the parameter string can be used without invoking HttpParams
       * by directly joining to the URL.
       * ```
       * this.httpClient.request('GET', this.heroesUrl + '?' + 'name=term', {responseType:'json'});
       * ```
       *
       *
       * ### JSONP Example
       * ```
       * requestJsonp(url, callback = 'callback') {
       *  return this.httpClient.jsonp(this.heroesURL, callback);
       * }
       * ```
       *
       * ### PATCH Example
       * ```
       * // PATCH one of the heroes' name
       * patchHero (id: number, heroName: string): Observable<{}> {
       * const url = `${this.heroesUrl}/${id}`;   // PATCH api/heroes/42
       *  return this.httpClient.patch(url, {name: heroName}, httpOptions)
       *    .pipe(catchError(this.handleError('patchHero')));
       * }
       * ```
       *
       * @see [HTTP Guide](guide/http)
       * @see [HTTP Request](api/common/http/HttpRequest)
       *
       * @publicApi
       */


      var _HttpClient = /*#__PURE__*/function () {
        function _HttpClient(handler) {
          _classCallCheck(this, _HttpClient);

          this.handler = handler;
        }
        /**
         * Constructs an observable for a generic HTTP request that, when subscribed,
         * fires the request through the chain of registered interceptors and on to the
         * server.
         *
         * You can pass an `HttpRequest` directly as the only parameter. In this case,
         * the call returns an observable of the raw `HttpEvent` stream.
         *
         * Alternatively you can pass an HTTP method as the first parameter,
         * a URL string as the second, and an options hash containing the request body as the third.
         * See `addBody()`. In this case, the specified `responseType` and `observe` options determine the
         * type of returned observable.
         *   * The `responseType` value determines how a successful response body is parsed.
         *   * If `responseType` is the default `json`, you can pass a type interface for the resulting
         * object as a type parameter to the call.
         *
         * The `observe` value determines the return type, according to what you are interested in
         * observing.
         *   * An `observe` value of events returns an observable of the raw `HttpEvent` stream, including
         * progress events by default.
         *   * An `observe` value of response returns an observable of `HttpResponse<T>`,
         * where the `T` parameter depends on the `responseType` and any optionally provided type
         * parameter.
         *   * An `observe` value of body returns an observable of `<T>` with the same `T` body type.
         *
         */


        _createClass(_HttpClient, [{
          key: "request",
          value: function request(first, url) {
            var _this12 = this;

            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var req; // First, check whether the primary argument is an instance of `HttpRequest`.

            if (first instanceof _HttpRequest) {
              // It is. The other arguments must be undefined (per the signatures) and can be
              // ignored.
              req = first;
            } else {
              // It's a string, so it represents a URL. Construct a request based on it,
              // and incorporate the remaining arguments (assuming `GET` unless a method is
              // provided.
              // Figure out the headers.
              var headers = undefined;

              if (options.headers instanceof _HttpHeaders) {
                headers = options.headers;
              } else {
                headers = new _HttpHeaders(options.headers);
              } // Sort out parameters.


              var params = undefined;

              if (!!options.params) {
                if (options.params instanceof _HttpParams) {
                  params = options.params;
                } else {
                  params = new _HttpParams({
                    fromObject: options.params
                  });
                }
              } // Construct the request.


              req = new _HttpRequest(first, url, options.body !== undefined ? options.body : null, {
                headers: headers,
                context: options.context,
                params: params,
                reportProgress: options.reportProgress,
                // By default, JSON is assumed to be returned for all calls.
                responseType: options.responseType || 'json',
                withCredentials: options.withCredentials
              });
            } // Start with an Observable.of() the initial request, and run the handler (which
            // includes all interceptors) inside a concatMap(). This way, the handler runs
            // inside an Observable chain, which causes interceptors to be re-run on every
            // subscription (this also makes retries re-run the handler, including interceptors).


            var events$ = (0, rxjs__WEBPACK_IMPORTED_MODULE_0__.of)(req).pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_1__.concatMap)(function (req) {
              return _this12.handler.handle(req);
            })); // If coming via the API signature which accepts a previously constructed HttpRequest,
            // the only option is to get the event stream. Otherwise, return the event stream if
            // that is what was requested.

            if (first instanceof _HttpRequest || options.observe === 'events') {
              return events$;
            } // The requested stream contains either the full response or the body. In either
            // case, the first step is to filter the event stream to extract a stream of
            // responses(s).


            var res$ = events$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_2__.filter)(function (event) {
              return event instanceof _HttpResponse;
            })); // Decide which stream to return.

            switch (options.observe || 'body') {
              case 'body':
                // The requested stream is the body. Map the response stream to the response
                // body. This could be done more simply, but a misbehaving interceptor might
                // transform the response body into a different format and ignore the requested
                // responseType. Guard against this by validating that the response is of the
                // requested type.
                switch (req.responseType) {
                  case 'arraybuffer':
                    return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                      // Validate that the body is an ArrayBuffer.
                      if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                        throw new Error('Response is not an ArrayBuffer.');
                      }

                      return res.body;
                    }));

                  case 'blob':
                    return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                      // Validate that the body is a Blob.
                      if (res.body !== null && !(res.body instanceof Blob)) {
                        throw new Error('Response is not a Blob.');
                      }

                      return res.body;
                    }));

                  case 'text':
                    return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                      // Validate that the body is a string.
                      if (res.body !== null && typeof res.body !== 'string') {
                        throw new Error('Response is not a string.');
                      }

                      return res.body;
                    }));

                  case 'json':
                  default:
                    // No validation needed for JSON responses, as they can be of any type.
                    return res$.pipe((0, rxjs_operators__WEBPACK_IMPORTED_MODULE_3__.map)(function (res) {
                      return res.body;
                    }));
                }

              case 'response':
                // The response stream was requested directly, so return it.
                return res$;

              default:
                // Guard against new future observe types being added.
                throw new Error("Unreachable: unhandled observe type ".concat(options.observe, "}"));
            }
          }
          /**
           * Constructs an observable that, when subscribed, causes the configured
           * `DELETE` request to execute on the server. See the individual overloads for
           * details on the return type.
           *
           * @param url     The endpoint URL.
           * @param options The HTTP options to send with the request.
           *
           */

        }, {
          key: "delete",
          value: function _delete(url) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return this.request('DELETE', url, options);
          }
          /**
           * Constructs an observable that, when subscribed, causes the configured
           * `GET` request to execute on the server. See the individual overloads for
           * details on the return type.
           */

        }, {
          key: "get",
          value: function get(url) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return this.request('GET', url, options);
          }
          /**
           * Constructs an observable that, when subscribed, causes the configured
           * `HEAD` request to execute on the server. The `HEAD` method returns
           * meta information about the resource without transferring the
           * resource itself. See the individual overloads for
           * details on the return type.
           */

        }, {
          key: "head",
          value: function head(url) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            return this.request('HEAD', url, options);
          }
          /**
           * Constructs an `Observable` that, when subscribed, causes a request with the special method
           * `JSONP` to be dispatched via the interceptor pipeline.
           * The [JSONP pattern](https://en.wikipedia.org/wiki/JSONP) works around limitations of certain
           * API endpoints that don't support newer,
           * and preferable [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) protocol.
           * JSONP treats the endpoint API as a JavaScript file and tricks the browser to process the
           * requests even if the API endpoint is not located on the same domain (origin) as the client-side
           * application making the request.
           * The endpoint API must support JSONP callback for JSONP requests to work.
           * The resource API returns the JSON response wrapped in a callback function.
           * You can pass the callback function name as one of the query parameters.
           * Note that JSONP requests can only be used with `GET` requests.
           *
           * @param url The resource URL.
           * @param callbackParam The callback function name.
           *
           */

        }, {
          key: "jsonp",
          value: function jsonp(url, callbackParam) {
            return this.request('JSONP', url, {
              params: new _HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
              observe: 'body',
              responseType: 'json'
            });
          }
          /**
           * Constructs an `Observable` that, when subscribed, causes the configured
           * `OPTIONS` request to execute on the server. This method allows the client
           * to determine the supported HTTP methods and other capabilites of an endpoint,
           * without implying a resource action. See the individual overloads for
           * details on the return type.
           */

        }, {
          key: "options",
          value: function options(url) {
            var _options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            return this.request('OPTIONS', url, _options);
          }
          /**
           * Constructs an observable that, when subscribed, causes the configured
           * `PATCH` request to execute on the server. See the individual overloads for
           * details on the return type.
           */

        }, {
          key: "patch",
          value: function patch(url, body) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            return this.request('PATCH', url, addBody(options, body));
          }
          /**
           * Constructs an observable that, when subscribed, causes the configured
           * `POST` request to execute on the server. The server responds with the location of
           * the replaced resource. See the individual overloads for
           * details on the return type.
           */

        }, {
          key: "post",
          value: function post(url, body) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            return this.request('POST', url, addBody(options, body));
          }
          /**
           * Constructs an observable that, when subscribed, causes the configured
           * `PUT` request to execute on the server. The `PUT` method replaces an existing resource
           * with a new set of values.
           * See the individual overloads for details on the return type.
           */

        }, {
          key: "put",
          value: function put(url, body) {
            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            return this.request('PUT', url, addBody(options, body));
          }
        }]);

        return _HttpClient;
      }();

      _HttpClient.ɵfac = function HttpClient_Factory(t) {
        return new (t || _HttpClient)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_HttpHandler));
      };

      _HttpClient.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: _HttpClient,
        factory: _HttpClient.ɵfac
      });

      _HttpClient.ctorParameters = function () {
        return [{
          type: _HttpHandler
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](_HttpClient, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], function () {
          return [{
            type: _HttpHandler
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
       *
       *
       */


      var HttpInterceptorHandler = /*#__PURE__*/function () {
        function HttpInterceptorHandler(next, interceptor) {
          _classCallCheck(this, HttpInterceptorHandler);

          this.next = next;
          this.interceptor = interceptor;
        }

        _createClass(HttpInterceptorHandler, [{
          key: "handle",
          value: function handle(req) {
            return this.interceptor.intercept(req, this.next);
          }
        }]);

        return HttpInterceptorHandler;
      }();
      /**
       * A multi-provider token that represents the array of registered
       * `HttpInterceptor` objects.
       *
       * @publicApi
       */


      var _HTTP_INTERCEPTORS = new _angular_core__WEBPACK_IMPORTED_MODULE_4__.InjectionToken('HTTP_INTERCEPTORS');

      var NoopInterceptor = /*#__PURE__*/function () {
        function NoopInterceptor() {
          _classCallCheck(this, NoopInterceptor);
        }

        _createClass(NoopInterceptor, [{
          key: "intercept",
          value: function intercept(req, next) {
            return next.handle(req);
          }
        }]);

        return NoopInterceptor;
      }();

      NoopInterceptor.ɵfac = function NoopInterceptor_Factory(t) {
        return new (t || NoopInterceptor)();
      };

      NoopInterceptor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: NoopInterceptor,
        factory: NoopInterceptor.ɵfac
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](NoopInterceptor, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], null, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */
      // Every request made through JSONP needs a callback name that's unique across the
      // whole page. Each request is assigned an id and the callback name is constructed
      // from that. The next id to be assigned is tracked in a global variable here that
      // is shared among all applications on the page.


      var nextRequestId = 0; // Error text given when a JSONP script is injected, but doesn't invoke the callback
      // passed in its URL.

      var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.'; // Error text given when a request is passed to the JsonpClientBackend that doesn't
      // have a request method JSONP.

      var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
      var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
      /**
       * DI token/abstract type representing a map of JSONP callbacks.
       *
       * In the browser, this should always be the `window` object.
       *
       *
       */

      var JsonpCallbackContext = function JsonpCallbackContext() {
        _classCallCheck(this, JsonpCallbackContext);
      };
      /**
       * Processes an `HttpRequest` with the JSONP method,
       * by performing JSONP style requests.
       * @see `HttpHandler`
       * @see `HttpXhrBackend`
       *
       * @publicApi
       */


      var _JsonpClientBackend = /*#__PURE__*/function () {
        function _JsonpClientBackend(callbackMap, document) {
          _classCallCheck(this, _JsonpClientBackend);

          this.callbackMap = callbackMap;
          this.document = document;
          /**
           * A resolved promise that can be used to schedule microtasks in the event handlers.
           */

          this.resolvedPromise = Promise.resolve();
        }
        /**
         * Get the name of the next callback method, by incrementing the global `nextRequestId`.
         */


        _createClass(_JsonpClientBackend, [{
          key: "nextCallback",
          value: function nextCallback() {
            return "ng_jsonp_callback_".concat(nextRequestId++);
          }
          /**
           * Processes a JSONP request and returns an event stream of the results.
           * @param req The request object.
           * @returns An observable of the response events.
           *
           */

        }, {
          key: "handle",
          value: function handle(req) {
            var _this13 = this;

            // Firstly, check both the method and response type. If either doesn't match
            // then the request was improperly routed here and cannot be handled.
            if (req.method !== 'JSONP') {
              throw new Error(JSONP_ERR_WRONG_METHOD);
            } else if (req.responseType !== 'json') {
              throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
            } // Everything else happens inside the Observable boundary.


            return new rxjs__WEBPACK_IMPORTED_MODULE_5__.Observable(function (observer) {
              // The first step to make a request is to generate the callback name, and replace the
              // callback placeholder in the URL with the name. Care has to be taken here to ensure
              // a trailing &, if matched, gets inserted back into the URL in the correct place.
              var callback = _this13.nextCallback();

              var url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=".concat(callback, "$1")); // Construct the <script> tag and point it at the URL.

              var node = _this13.document.createElement('script');

              node.src = url; // A JSONP request requires waiting for multiple callbacks. These variables
              // are closed over and track state across those callbacks.
              // The response object, if one has been received, or null otherwise.

              var body = null; // Whether the response callback has been called.

              var finished = false; // Whether the request has been cancelled (and thus any other callbacks)
              // should be ignored.

              var cancelled = false; // Set the response callback in this.callbackMap (which will be the window
              // object in the browser. The script being loaded via the <script> tag will
              // eventually call this callback.

              _this13.callbackMap[callback] = function (data) {
                // Data has been received from the JSONP script. Firstly, delete this callback.
                delete _this13.callbackMap[callback]; // Next, make sure the request wasn't cancelled in the meantime.

                if (cancelled) {
                  return;
                } // Set state to indicate data was received.


                body = data;
                finished = true;
              }; // cleanup() is a utility closure that removes the <script> from the page and
              // the response callback from the window. This logic is used in both the
              // success, error, and cancellation paths, so it's extracted out for convenience.


              var cleanup = function cleanup() {
                // Remove the <script> tag if it's still on the page.
                if (node.parentNode) {
                  node.parentNode.removeChild(node);
                } // Remove the response callback from the callbackMap (window object in the
                // browser).


                delete _this13.callbackMap[callback];
              }; // onLoad() is the success callback which runs after the response callback
              // if the JSONP script loads successfully. The event itself is unimportant.
              // If something went wrong, onLoad() may run without the response callback
              // having been invoked.


              var onLoad = function onLoad(event) {
                // Do nothing if the request has been cancelled.
                if (cancelled) {
                  return;
                } // We wrap it in an extra Promise, to ensure the microtask
                // is scheduled after the loaded endpoint has executed any potential microtask itself,
                // which is not guaranteed in Internet Explorer and EdgeHTML. See issue #39496


                _this13.resolvedPromise.then(function () {
                  // Cleanup the page.
                  cleanup(); // Check whether the response callback has run.

                  if (!finished) {
                    // It hasn't, something went wrong with the request. Return an error via
                    // the Observable error path. All JSONP errors have status 0.
                    observer.error(new _HttpErrorResponse({
                      url: url,
                      status: 0,
                      statusText: 'JSONP Error',
                      error: new Error(JSONP_ERR_NO_CALLBACK)
                    }));
                    return;
                  } // Success. body either contains the response body or null if none was
                  // returned.


                  observer.next(new _HttpResponse({
                    body: body,
                    status: 200
                    /* Ok */
                    ,
                    statusText: 'OK',
                    url: url
                  })); // Complete the stream, the response is over.

                  observer.complete();
                });
              }; // onError() is the error callback, which runs if the script returned generates
              // a Javascript error. It emits the error via the Observable error channel as
              // a HttpErrorResponse.


              var onError = function onError(error) {
                // If the request was already cancelled, no need to emit anything.
                if (cancelled) {
                  return;
                }

                cleanup(); // Wrap the error in a HttpErrorResponse.

                observer.error(new _HttpErrorResponse({
                  error: error,
                  status: 0,
                  statusText: 'JSONP Error',
                  url: url
                }));
              }; // Subscribe to both the success (load) and error events on the <script> tag,
              // and add it to the page.


              node.addEventListener('load', onLoad);
              node.addEventListener('error', onError);

              _this13.document.body.appendChild(node); // The request has now been successfully sent.


              observer.next({
                type: _HttpEventType.Sent
              }); // Cancellation handler.

              return function () {
                // Track the cancellation so event listeners won't do anything even if already scheduled.
                cancelled = true; // Remove the event listeners so they won't run if the events later fire.

                node.removeEventListener('load', onLoad);
                node.removeEventListener('error', onError); // And finally, clean up the page.

                cleanup();
              };
            });
          }
        }]);

        return _JsonpClientBackend;
      }();

      _JsonpClientBackend.ɵfac = function JsonpClientBackend_Factory(t) {
        return new (t || _JsonpClientBackend)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](JsonpCallbackContext), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_6__.DOCUMENT));
      };

      _JsonpClientBackend.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: _JsonpClientBackend,
        factory: _JsonpClientBackend.ɵfac
      });

      _JsonpClientBackend.ctorParameters = function () {
        return [{
          type: JsonpCallbackContext
        }, {
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__.DOCUMENT]
          }]
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](_JsonpClientBackend, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], function () {
          return [{
            type: JsonpCallbackContext
          }, {
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__.DOCUMENT]
            }]
          }];
        }, null);
      })();
      /**
       * Identifies requests with the method JSONP and
       * shifts them to the `JsonpClientBackend`.
       *
       * @see `HttpInterceptor`
       *
       * @publicApi
       */


      var _JsonpInterceptor = /*#__PURE__*/function () {
        function _JsonpInterceptor(jsonp) {
          _classCallCheck(this, _JsonpInterceptor);

          this.jsonp = jsonp;
        }
        /**
         * Identifies and handles a given JSONP request.
         * @param req The outgoing request object to handle.
         * @param next The next interceptor in the chain, or the backend
         * if no interceptors remain in the chain.
         * @returns An observable of the event stream.
         */


        _createClass(_JsonpInterceptor, [{
          key: "intercept",
          value: function intercept(req, next) {
            if (req.method === 'JSONP') {
              return this.jsonp.handle(req);
            } // Fall through for normal HTTP requests.


            return next.handle(req);
          }
        }]);

        return _JsonpInterceptor;
      }();

      _JsonpInterceptor.ɵfac = function JsonpInterceptor_Factory(t) {
        return new (t || _JsonpInterceptor)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_JsonpClientBackend));
      };

      _JsonpInterceptor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: _JsonpInterceptor,
        factory: _JsonpInterceptor.ɵfac
      });

      _JsonpInterceptor.ctorParameters = function () {
        return [{
          type: _JsonpClientBackend
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](_JsonpInterceptor, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], function () {
          return [{
            type: _JsonpClientBackend
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var XSSI_PREFIX = /^\)\]\}',?\n/;
      /**
       * Determine an appropriate URL for the response, by checking either
       * XMLHttpRequest.responseURL or the X-Request-URL header.
       */

      function getResponseUrl(xhr) {
        if ('responseURL' in xhr && xhr.responseURL) {
          return xhr.responseURL;
        }

        if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
          return xhr.getResponseHeader('X-Request-URL');
        }

        return null;
      }
      /**
       * Uses `XMLHttpRequest` to send requests to a backend server.
       * @see `HttpHandler`
       * @see `JsonpClientBackend`
       *
       * @publicApi
       */


      var _HttpXhrBackend = /*#__PURE__*/function () {
        function _HttpXhrBackend(xhrFactory) {
          _classCallCheck(this, _HttpXhrBackend);

          this.xhrFactory = xhrFactory;
        }
        /**
         * Processes a request and returns a stream of response events.
         * @param req The request object.
         * @returns An observable of the response events.
         */


        _createClass(_HttpXhrBackend, [{
          key: "handle",
          value: function handle(req) {
            var _this14 = this;

            // Quick check to give a better error message when a user attempts to use
            // HttpClient.jsonp() without installing the HttpClientJsonpModule
            if (req.method === 'JSONP') {
              throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed.");
            } // Everything happens on Observable subscription.


            return new rxjs__WEBPACK_IMPORTED_MODULE_5__.Observable(function (observer) {
              // Start by setting up the XHR object with request method, URL, and withCredentials flag.
              var xhr = _this14.xhrFactory.build();

              xhr.open(req.method, req.urlWithParams);

              if (!!req.withCredentials) {
                xhr.withCredentials = true;
              } // Add all the requested headers.


              req.headers.forEach(function (name, values) {
                return xhr.setRequestHeader(name, values.join(','));
              }); // Add an Accept header if one isn't present already.

              if (!req.headers.has('Accept')) {
                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
              } // Auto-detect the Content-Type header if one isn't present already.


              if (!req.headers.has('Content-Type')) {
                var detectedType = req.detectContentTypeHeader(); // Sometimes Content-Type detection fails.

                if (detectedType !== null) {
                  xhr.setRequestHeader('Content-Type', detectedType);
                }
              } // Set the responseType if one was requested.


              if (req.responseType) {
                var responseType = req.responseType.toLowerCase(); // JSON responses need to be processed as text. This is because if the server
                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,
                // xhr.response will be null, and xhr.responseText cannot be accessed to
                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON
                // is parsed by first requesting text and then applying JSON.parse.

                xhr.responseType = responseType !== 'json' ? responseType : 'text';
              } // Serialize the request body if one is present. If not, this will be set to null.


              var reqBody = req.serializeBody(); // If progress events are enabled, response headers will be delivered
              // in two events - the HttpHeaderResponse event and the full HttpResponse
              // event. However, since response headers don't change in between these
              // two events, it doesn't make sense to parse them twice. So headerResponse
              // caches the data extracted from the response whenever it's first parsed,
              // to ensure parsing isn't duplicated.

              var headerResponse = null; // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
              // state, and memoizes it into headerResponse.

              var partialFromXhr = function partialFromXhr() {
                if (headerResponse !== null) {
                  return headerResponse;
                } // Read status and normalize an IE9 bug (https://bugs.jquery.com/ticket/1450).


                var status = xhr.status === 1223 ? 204
                /* NoContent */
                : xhr.status;
                var statusText = xhr.statusText || 'OK'; // Parse headers from XMLHttpRequest - this step is lazy.

                var headers = new _HttpHeaders(xhr.getAllResponseHeaders()); // Read the response URL from the XMLHttpResponse instance and fall back on the
                // request URL.

                var url = getResponseUrl(xhr) || req.url; // Construct the HttpHeaderResponse and memoize it.

                headerResponse = new _HttpHeaderResponse({
                  headers: headers,
                  status: status,
                  statusText: statusText,
                  url: url
                });
                return headerResponse;
              }; // Next, a few closures are defined for the various events which XMLHttpRequest can
              // emit. This allows them to be unregistered as event listeners later.
              // First up is the load event, which represents a response being fully available.


              var onLoad = function onLoad() {
                // Read response state from the memoized partial data.
                var _partialFromXhr = partialFromXhr(),
                    headers = _partialFromXhr.headers,
                    status = _partialFromXhr.status,
                    statusText = _partialFromXhr.statusText,
                    url = _partialFromXhr.url; // The body will be read out if present.


                var body = null;

                if (status !== 204
                /* NoContent */
                ) {
                  // Use XMLHttpRequest.response if set, responseText otherwise.
                  body = typeof xhr.response === 'undefined' ? xhr.responseText : xhr.response;
                } // Normalize another potential bug (this one comes from CORS).


                if (status === 0) {
                  status = !!body ? 200
                  /* Ok */
                  : 0;
                } // ok determines whether the response will be transmitted on the event or
                // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                // but a successful status code can still result in an error if the user
                // asked for JSON data and the body cannot be parsed as such.


                var ok = status >= 200 && status < 300; // Check whether the body needs to be parsed as JSON (in many cases the browser
                // will have done that already).

                if (req.responseType === 'json' && typeof body === 'string') {
                  // Save the original body, before attempting XSSI prefix stripping.
                  var originalBody = body;
                  body = body.replace(XSSI_PREFIX, '');

                  try {
                    // Attempt the parse. If it fails, a parse error should be delivered to the user.
                    body = body !== '' ? JSON.parse(body) : null;
                  } catch (error) {
                    // Since the JSON.parse failed, it's reasonable to assume this might not have been a
                    // JSON response. Restore the original body (including any XSSI prefix) to deliver
                    // a better error response.
                    body = originalBody; // If this was an error request to begin with, leave it as a string, it probably
                    // just isn't JSON. Otherwise, deliver the parsing error to the user.

                    if (ok) {
                      // Even though the response status was 2xx, this is still an error.
                      ok = false; // The parse error contains the text of the body that failed to parse.

                      body = {
                        error: error,
                        text: body
                      };
                    }
                  }
                }

                if (ok) {
                  // A successful response is delivered on the event stream.
                  observer.next(new _HttpResponse({
                    body: body,
                    headers: headers,
                    status: status,
                    statusText: statusText,
                    url: url || undefined
                  })); // The full body has been received and delivered, no further events
                  // are possible. This request is complete.

                  observer.complete();
                } else {
                  // An unsuccessful request is delivered on the error channel.
                  observer.error(new _HttpErrorResponse({
                    // The error in this case is the response body (error from the server).
                    error: body,
                    headers: headers,
                    status: status,
                    statusText: statusText,
                    url: url || undefined
                  }));
                }
              }; // The onError callback is called when something goes wrong at the network level.
              // Connection timeout, DNS error, offline, etc. These are actual errors, and are
              // transmitted on the error channel.


              var onError = function onError(error) {
                var _partialFromXhr2 = partialFromXhr(),
                    url = _partialFromXhr2.url;

                var res = new _HttpErrorResponse({
                  error: error,
                  status: xhr.status || 0,
                  statusText: xhr.statusText || 'Unknown Error',
                  url: url || undefined
                });
                observer.error(res);
              }; // The sentHeaders flag tracks whether the HttpResponseHeaders event
              // has been sent on the stream. This is necessary to track if progress
              // is enabled since the event will be sent on only the first download
              // progerss event.


              var sentHeaders = false; // The download progress event handler, which is only registered if
              // progress events are enabled.

              var onDownProgress = function onDownProgress(event) {
                // Send the HttpResponseHeaders event if it hasn't been sent already.
                if (!sentHeaders) {
                  observer.next(partialFromXhr());
                  sentHeaders = true;
                } // Start building the download progress event to deliver on the response
                // event stream.


                var progressEvent = {
                  type: _HttpEventType.DownloadProgress,
                  loaded: event.loaded
                }; // Set the total number of bytes in the event if it's available.

                if (event.lengthComputable) {
                  progressEvent.total = event.total;
                } // If the request was for text content and a partial response is
                // available on XMLHttpRequest, include it in the progress event
                // to allow for streaming reads.


                if (req.responseType === 'text' && !!xhr.responseText) {
                  progressEvent.partialText = xhr.responseText;
                } // Finally, fire the event.


                observer.next(progressEvent);
              }; // The upload progress event handler, which is only registered if
              // progress events are enabled.


              var onUpProgress = function onUpProgress(event) {
                // Upload progress events are simpler. Begin building the progress
                // event.
                var progress = {
                  type: _HttpEventType.UploadProgress,
                  loaded: event.loaded
                }; // If the total number of bytes being uploaded is available, include
                // it.

                if (event.lengthComputable) {
                  progress.total = event.total;
                } // Send the event.


                observer.next(progress);
              }; // By default, register for load and error events.


              xhr.addEventListener('load', onLoad);
              xhr.addEventListener('error', onError);
              xhr.addEventListener('timeout', onError);
              xhr.addEventListener('abort', onError); // Progress events are only enabled if requested.

              if (req.reportProgress) {
                // Download progress is always enabled if requested.
                xhr.addEventListener('progress', onDownProgress); // Upload progress depends on whether there is a body to upload.

                if (reqBody !== null && xhr.upload) {
                  xhr.upload.addEventListener('progress', onUpProgress);
                }
              } // Fire the request, and notify the event stream that it was fired.


              xhr.send(reqBody);
              observer.next({
                type: _HttpEventType.Sent
              }); // This is the return from the Observable function, which is the
              // request cancellation handler.

              return function () {
                // On a cancellation, remove all registered event listeners.
                xhr.removeEventListener('error', onError);
                xhr.removeEventListener('abort', onError);
                xhr.removeEventListener('load', onLoad);
                xhr.removeEventListener('timeout', onError);

                if (req.reportProgress) {
                  xhr.removeEventListener('progress', onDownProgress);

                  if (reqBody !== null && xhr.upload) {
                    xhr.upload.removeEventListener('progress', onUpProgress);
                  }
                } // Finally, abort the in-flight request.


                if (xhr.readyState !== xhr.DONE) {
                  xhr.abort();
                }
              };
            });
          }
        }]);

        return _HttpXhrBackend;
      }();

      _HttpXhrBackend.ɵfac = function HttpXhrBackend_Factory(t) {
        return new (t || _HttpXhrBackend)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_6__.XhrFactory));
      };

      _HttpXhrBackend.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: _HttpXhrBackend,
        factory: _HttpXhrBackend.ɵfac
      });

      _HttpXhrBackend.ctorParameters = function () {
        return [{
          type: _angular_common__WEBPACK_IMPORTED_MODULE_6__.XhrFactory
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](_HttpXhrBackend, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], function () {
          return [{
            type: _angular_common__WEBPACK_IMPORTED_MODULE_6__.XhrFactory
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */


      var XSRF_COOKIE_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_4__.InjectionToken('XSRF_COOKIE_NAME');
      var XSRF_HEADER_NAME = new _angular_core__WEBPACK_IMPORTED_MODULE_4__.InjectionToken('XSRF_HEADER_NAME');
      /**
       * Retrieves the current XSRF token to use with the next outgoing request.
       *
       * @publicApi
       */

      var _HttpXsrfTokenExtractor = function _HttpXsrfTokenExtractor() {
        _classCallCheck(this, _HttpXsrfTokenExtractor);
      };
      /**
       * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
       */


      var HttpXsrfCookieExtractor = /*#__PURE__*/function () {
        function HttpXsrfCookieExtractor(doc, platform, cookieName) {
          _classCallCheck(this, HttpXsrfCookieExtractor);

          this.doc = doc;
          this.platform = platform;
          this.cookieName = cookieName;
          this.lastCookieString = '';
          this.lastToken = null;
          /**
           * @internal for testing
           */

          this.parseCount = 0;
        }

        _createClass(HttpXsrfCookieExtractor, [{
          key: "getToken",
          value: function getToken() {
            if (this.platform === 'server') {
              return null;
            }

            var cookieString = this.doc.cookie || '';

            if (cookieString !== this.lastCookieString) {
              this.parseCount++;
              this.lastToken = (0, _angular_common__WEBPACK_IMPORTED_MODULE_6__["ɵparseCookieValue"])(cookieString, this.cookieName);
              this.lastCookieString = cookieString;
            }

            return this.lastToken;
          }
        }]);

        return HttpXsrfCookieExtractor;
      }();

      HttpXsrfCookieExtractor.ɵfac = function HttpXsrfCookieExtractor_Factory(t) {
        return new (t || HttpXsrfCookieExtractor)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_angular_common__WEBPACK_IMPORTED_MODULE_6__.DOCUMENT), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_4__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](XSRF_COOKIE_NAME));
      };

      HttpXsrfCookieExtractor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: HttpXsrfCookieExtractor,
        factory: HttpXsrfCookieExtractor.ɵfac
      });

      HttpXsrfCookieExtractor.ctorParameters = function () {
        return [{
          type: undefined,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
            args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__.DOCUMENT]
          }]
        }, {
          type: String,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_4__.PLATFORM_ID]
          }]
        }, {
          type: String,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
            args: [XSRF_COOKIE_NAME]
          }]
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](HttpXsrfCookieExtractor, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], function () {
          return [{
            type: undefined,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
              args: [_angular_common__WEBPACK_IMPORTED_MODULE_6__.DOCUMENT]
            }]
          }, {
            type: String,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
              args: [_angular_core__WEBPACK_IMPORTED_MODULE_4__.PLATFORM_ID]
            }]
          }, {
            type: String,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
              args: [XSRF_COOKIE_NAME]
            }]
          }];
        }, null);
      })();
      /**
       * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
       */


      var HttpXsrfInterceptor = /*#__PURE__*/function () {
        function HttpXsrfInterceptor(tokenService, headerName) {
          _classCallCheck(this, HttpXsrfInterceptor);

          this.tokenService = tokenService;
          this.headerName = headerName;
        }

        _createClass(HttpXsrfInterceptor, [{
          key: "intercept",
          value: function intercept(req, next) {
            var lcUrl = req.url.toLowerCase(); // Skip both non-mutating requests and absolute URLs.
            // Non-mutating requests don't require a token, and absolute URLs require special handling
            // anyway as the cookie set
            // on our origin is not the same as the token expected by another origin.

            if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') || lcUrl.startsWith('https://')) {
              return next.handle(req);
            }

            var token = this.tokenService.getToken(); // Be careful not to overwrite an existing header of the same name.

            if (token !== null && !req.headers.has(this.headerName)) {
              req = req.clone({
                headers: req.headers.set(this.headerName, token)
              });
            }

            return next.handle(req);
          }
        }]);

        return HttpXsrfInterceptor;
      }();

      HttpXsrfInterceptor.ɵfac = function HttpXsrfInterceptor_Factory(t) {
        return new (t || HttpXsrfInterceptor)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_HttpXsrfTokenExtractor), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](XSRF_HEADER_NAME));
      };

      HttpXsrfInterceptor.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: HttpXsrfInterceptor,
        factory: HttpXsrfInterceptor.ɵfac
      });

      HttpXsrfInterceptor.ctorParameters = function () {
        return [{
          type: _HttpXsrfTokenExtractor
        }, {
          type: String,
          decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
            args: [XSRF_HEADER_NAME]
          }]
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](HttpXsrfInterceptor, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], function () {
          return [{
            type: _HttpXsrfTokenExtractor
          }, {
            type: String,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
              args: [XSRF_HEADER_NAME]
            }]
          }];
        }, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * An injectable `HttpHandler` that applies multiple interceptors
       * to a request before passing it to the given `HttpBackend`.
       *
       * The interceptors are loaded lazily from the injector, to allow
       * interceptors to themselves inject classes depending indirectly
       * on `HttpInterceptingHandler` itself.
       * @see `HttpInterceptor`
       */


      var HttpInterceptingHandler = /*#__PURE__*/function () {
        function HttpInterceptingHandler(backend, injector) {
          _classCallCheck(this, HttpInterceptingHandler);

          this.backend = backend;
          this.injector = injector;
          this.chain = null;
        }

        _createClass(HttpInterceptingHandler, [{
          key: "handle",
          value: function handle(req) {
            if (this.chain === null) {
              var interceptors = this.injector.get(_HTTP_INTERCEPTORS, []);
              this.chain = interceptors.reduceRight(function (next, interceptor) {
                return new HttpInterceptorHandler(next, interceptor);
              }, this.backend);
            }

            return this.chain.handle(req);
          }
        }]);

        return HttpInterceptingHandler;
      }();

      HttpInterceptingHandler.ɵfac = function HttpInterceptingHandler_Factory(t) {
        return new (t || HttpInterceptingHandler)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_HttpBackend), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_4__.Injector));
      };

      HttpInterceptingHandler.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
        token: HttpInterceptingHandler,
        factory: HttpInterceptingHandler.ɵfac
      });

      HttpInterceptingHandler.ctorParameters = function () {
        return [{
          type: _HttpBackend
        }, {
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injector
        }];
      };

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](HttpInterceptingHandler, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
        }], function () {
          return [{
            type: _HttpBackend
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injector
          }];
        }, null);
      })();
      /**
       * Constructs an `HttpHandler` that applies interceptors
       * to a request before passing it to the given `HttpBackend`.
       *
       * Use as a factory function within `HttpClientModule`.
       *
       *
       */


      function interceptingHandler(backend) {
        var interceptors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (!interceptors) {
          return backend;
        }

        return interceptors.reduceRight(function (next, interceptor) {
          return new HttpInterceptorHandler(next, interceptor);
        }, backend);
      }
      /**
       * Factory function that determines where to store JSONP callbacks.
       *
       * Ordinarily JSONP callbacks are stored on the `window` object, but this may not exist
       * in test environments. In that case, callbacks are stored on an anonymous object instead.
       *
       *
       */


      function jsonpCallbackContext() {
        if (typeof window === 'object') {
          return window;
        }

        return {};
      }
      /**
       * Configures XSRF protection support for outgoing requests.
       *
       * For a server that supports a cookie-based XSRF protection system,
       * use directly to configure XSRF protection with the correct
       * cookie and header names.
       *
       * If no names are supplied, the default cookie name is `XSRF-TOKEN`
       * and the default header name is `X-XSRF-TOKEN`.
       *
       * @publicApi
       */


      var _HttpClientXsrfModule = /*#__PURE__*/function () {
        function _HttpClientXsrfModule() {
          _classCallCheck(this, _HttpClientXsrfModule);
        }

        _createClass(_HttpClientXsrfModule, null, [{
          key: "disable",
          value:
          /**
           * Disable the default XSRF protection.
           */
          function disable() {
            return {
              ngModule: _HttpClientXsrfModule,
              providers: [{
                provide: HttpXsrfInterceptor,
                useClass: NoopInterceptor
              }]
            };
          }
          /**
           * Configure XSRF protection.
           * @param options An object that can specify either or both
           * cookie name or header name.
           * - Cookie name default is `XSRF-TOKEN`.
           * - Header name default is `X-XSRF-TOKEN`.
           *
           */

        }, {
          key: "withOptions",
          value: function withOptions() {
            var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
            return {
              ngModule: _HttpClientXsrfModule,
              providers: [options.cookieName ? {
                provide: XSRF_COOKIE_NAME,
                useValue: options.cookieName
              } : [], options.headerName ? {
                provide: XSRF_HEADER_NAME,
                useValue: options.headerName
              } : []]
            };
          }
        }]);

        return _HttpClientXsrfModule;
      }();

      _HttpClientXsrfModule.ɵfac = function HttpClientXsrfModule_Factory(t) {
        return new (t || _HttpClientXsrfModule)();
      };

      _HttpClientXsrfModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineNgModule"]({
        type: _HttpClientXsrfModule
      });
      _HttpClientXsrfModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjector"]({
        providers: [HttpXsrfInterceptor, {
          provide: _HTTP_INTERCEPTORS,
          useExisting: HttpXsrfInterceptor,
          multi: true
        }, {
          provide: _HttpXsrfTokenExtractor,
          useClass: HttpXsrfCookieExtractor
        }, {
          provide: XSRF_COOKIE_NAME,
          useValue: 'XSRF-TOKEN'
        }, {
          provide: XSRF_HEADER_NAME,
          useValue: 'X-XSRF-TOKEN'
        }]
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](_HttpClientXsrfModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.NgModule,
          args: [{
            providers: [HttpXsrfInterceptor, {
              provide: _HTTP_INTERCEPTORS,
              useExisting: HttpXsrfInterceptor,
              multi: true
            }, {
              provide: _HttpXsrfTokenExtractor,
              useClass: HttpXsrfCookieExtractor
            }, {
              provide: XSRF_COOKIE_NAME,
              useValue: 'XSRF-TOKEN'
            }, {
              provide: XSRF_HEADER_NAME,
              useValue: 'X-XSRF-TOKEN'
            }]
          }]
        }], null, null);
      })();
      /**
       * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`
       * with supporting services for XSRF. Automatically imported by `HttpClientModule`.
       *
       * You can add interceptors to the chain behind `HttpClient` by binding them to the
       * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.
       *
       * @publicApi
       */


      var _HttpClientModule = function _HttpClientModule() {
        _classCallCheck(this, _HttpClientModule);
      };

      _HttpClientModule.ɵfac = function HttpClientModule_Factory(t) {
        return new (t || _HttpClientModule)();
      };

      _HttpClientModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineNgModule"]({
        type: _HttpClientModule
      });
      _HttpClientModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjector"]({
        providers: [_HttpClient, {
          provide: _HttpHandler,
          useClass: HttpInterceptingHandler
        }, _HttpXhrBackend, {
          provide: _HttpBackend,
          useExisting: _HttpXhrBackend
        }],
        imports: [[_HttpClientXsrfModule.withOptions({
          cookieName: 'XSRF-TOKEN',
          headerName: 'X-XSRF-TOKEN'
        })]]
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](_HttpClientModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.NgModule,
          args: [{
            /**
             * Optional configuration for XSRF protection.
             */
            imports: [_HttpClientXsrfModule.withOptions({
              cookieName: 'XSRF-TOKEN',
              headerName: 'X-XSRF-TOKEN'
            })],

            /**
             * Configures the [dependency injector](guide/glossary#injector) where it is imported
             * with supporting services for HTTP communications.
             */
            providers: [_HttpClient, {
              provide: _HttpHandler,
              useClass: HttpInterceptingHandler
            }, _HttpXhrBackend, {
              provide: _HttpBackend,
              useExisting: _HttpXhrBackend
            }]
          }]
        }], null, null);
      })();

      (function () {
        (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵsetNgModuleScope"](_HttpClientModule, {
          imports: [_HttpClientXsrfModule]
        });
      })();
      /**
       * Configures the [dependency injector](guide/glossary#injector) for `HttpClient`
       * with supporting services for JSONP.
       * Without this module, Jsonp requests reach the backend
       * with method JSONP, where they are rejected.
       *
       * You can add interceptors to the chain behind `HttpClient` by binding them to the
       * multiprovider for built-in [DI token](guide/glossary#di-token) `HTTP_INTERCEPTORS`.
       *
       * @publicApi
       */


      var _HttpClientJsonpModule = function _HttpClientJsonpModule() {
        _classCallCheck(this, _HttpClientJsonpModule);
      };

      _HttpClientJsonpModule.ɵfac = function HttpClientJsonpModule_Factory(t) {
        return new (t || _HttpClientJsonpModule)();
      };

      _HttpClientJsonpModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineNgModule"]({
        type: _HttpClientJsonpModule
      });
      _HttpClientJsonpModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjector"]({
        providers: [_JsonpClientBackend, {
          provide: JsonpCallbackContext,
          useFactory: jsonpCallbackContext
        }, {
          provide: _HTTP_INTERCEPTORS,
          useClass: _JsonpInterceptor,
          multi: true
        }]
      });

      (function () {
        (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](_HttpClientJsonpModule, [{
          type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.NgModule,
          args: [{
            providers: [_JsonpClientBackend, {
              provide: JsonpCallbackContext,
              useFactory: jsonpCallbackContext
            }, {
              provide: _HTTP_INTERCEPTORS,
              useClass: _JsonpInterceptor,
              multi: true
            }]
          }]
        }], null, null);
      })();
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * A wrapper around the `XMLHttpRequest` constructor.
       *
       * @publicApi
       * @see `XhrFactory`
       * @deprecated
       * `XhrFactory` has moved, please import `XhrFactory` from `@angular/common` instead.
       */


      var _XhrFactory = _angular_common__WEBPACK_IMPORTED_MODULE_6__.XhrFactory;
      /**
       * @license
       * Copyright Google LLC All Rights Reserved.
       *
       * Use of this source code is governed by an MIT-style license that can be
       * found in the LICENSE file at https://angular.io/license
       */

      /**
       * Generated bundle index. Do not edit.
       */
      //# sourceMappingURL=http.js.map

      /***/
    },

    /***/
    48482: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "AutoCompleteComponent": function AutoCompleteComponent() {
          return (
            /* binding */
            _AutoCompleteComponent
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/common */
      38583);
      /* harmony import */


      var _windowRef_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./windowRef.service */
      56313);
      /* harmony import */


      var _auto_complete_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./auto-complete.service */
      16674);
      /* harmony import */


      var _angular_forms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/forms */
      3679);

      var _c0 = function _c0(a0) {
        return {
          "background-image": a0
        };
      };

      function AutoCompleteComponent_div_0_button_4_i_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "i", 12);
        }

        if (rf & 2) {
          var ctx_r5 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngStyle", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction1"](1, _c0, "url(" + ctx_r5.settings.searchIconUrl + ")"));
        }
      }

      function AutoCompleteComponent_div_0_button_4_i_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "i", 13);
        }
      }

      function AutoCompleteComponent_div_0_button_4_Template(rf, ctx) {
        if (rf & 1) {
          var _r8 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "button", 9);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("click", function AutoCompleteComponent_div_0_button_4_Template_button_click_0_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r8);

            var ctx_r7 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](2);

            return ctx_r7.userQuerySubmit();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](1, AutoCompleteComponent_div_0_button_4_i_1_Template, 1, 3, "i", 10);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](2, AutoCompleteComponent_div_0_button_4_i_2_Template, 1, 0, "i", 11);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r2 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r2.settings.searchIconUrl);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", !ctx_r2.settings.searchIconUrl);
        }
      }

      function AutoCompleteComponent_div_0_pre_5_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "pre", 14);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](1, "i", 15);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_1_i_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "i", 24);
        }

        if (rf & 2) {
          var ctx_r13 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngStyle", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction1"](1, _c0, "url(" + ctx_r13.settings.currentLocIconUrl + ")"));
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_1_i_4_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "i", 25);
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_1_Template(rf, ctx) {
        if (rf & 1) {
          var _r16 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "li", 20);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](1, "a", 21);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("click", function AutoCompleteComponent_div_0_ul_6_li_1_Template_a_click_1_listener() {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r16);

            var ctx_r15 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

            return ctx_r15.currentLocationSelected();
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](2, AutoCompleteComponent_div_0_ul_6_li_1_i_2_Template, 1, 3, "i", 22);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](3, "Use Current Location ");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](4, AutoCompleteComponent_div_0_ul_6_li_1_i_4_Template, 1, 0, "i", 23);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r9 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r9.settings.currentLocIconUrl);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", !ctx_r9.settings.currentLocIconUrl);
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "li", 26);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](1, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](2, "Locations");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](3, "span", 27);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "li", 26);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](1, "span");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](2, "Recent Searches");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](3, "span", 28);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_4_i_2_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "i", 35);
        }

        if (rf & 2) {
          var ctx_r19 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](4);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngStyle", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction1"](1, _c0, "url(" + ctx_r19.settings.locationIconUrl + ")"));
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_4_i_3_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelement"](0, "i", 36);
        }
      }

      function AutoCompleteComponent_div_0_ul_6_li_4_span_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "span", 37);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var data_r17 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]().$implicit;

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate"](data_r17.structured_formatting.secondary_text);
        }
      }

      var _c1 = function _c1(a0) {
        return {
          "active": a0
        };
      };

      function AutoCompleteComponent_div_0_ul_6_li_4_Template(rf, ctx) {
        if (rf & 1) {
          var _r24 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "li", 29);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](1, "a", 30);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("mouseover", function AutoCompleteComponent_div_0_ul_6_li_4_Template_a_mouseover_1_listener() {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r24);

            var $index_r18 = restoredCtx.index;

            var ctx_r23 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

            return ctx_r23.activeListNode($index_r18);
          })("click", function AutoCompleteComponent_div_0_ul_6_li_4_Template_a_click_1_listener() {
            var restoredCtx = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r24);

            var $index_r18 = restoredCtx.index;

            var ctx_r25 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

            return ctx_r25.selectedListNode($index_r18);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](2, AutoCompleteComponent_div_0_ul_6_li_4_i_2_Template, 1, 3, "i", 31);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](3, AutoCompleteComponent_div_0_ul_6_li_4_i_3_Template, 1, 0, "i", 32);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](4, "span", 33);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](5);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](6, AutoCompleteComponent_div_0_ul_6_li_4_span_6_Template, 2, 1, "span", 34);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var data_r17 = ctx.$implicit;

          var ctx_r12 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction1"](5, _c1, data_r17.active));

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r12.settings.locationIconUrl);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", !ctx_r12.settings.locationIconUrl);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate1"](" ", (data_r17.structured_formatting == null ? null : data_r17.structured_formatting.main_text) ? data_r17.structured_formatting.main_text : data_r17.description, " ");

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", data_r17.structured_formatting == null ? null : data_r17.structured_formatting.secondary_text);
        }
      }

      function AutoCompleteComponent_div_0_ul_6_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "ul", 16);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](1, AutoCompleteComponent_div_0_ul_6_li_1_Template, 5, 2, "li", 17);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](2, AutoCompleteComponent_div_0_ul_6_li_2_Template, 4, 0, "li", 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](3, AutoCompleteComponent_div_0_ul_6_li_3_Template, 4, 0, "li", 18);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](4, AutoCompleteComponent_div_0_ul_6_li_4_Template, 7, 7, "li", 19);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r4 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r4.settings.showCurrentLocation);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", !ctx_r4.recentDropdownOpen && ctx_r4.queryItems.length);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r4.recentDropdownOpen && ctx_r4.queryItems.length);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngForOf", ctx_r4.queryItems);
        }
      }

      var _c2 = function _c2(a0) {
        return {
          "button-included": a0
        };
      };

      function AutoCompleteComponent_div_0_Template(rf, ctx) {
        if (rf & 1) {
          var _r27 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵgetCurrentView"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "div", 2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](1, "div", 3);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](2, "div", 4);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](3, "input", 5);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("ngModelChange", function AutoCompleteComponent_div_0_Template_input_ngModelChange_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r27);

            var ctx_r26 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

            return ctx_r26.locationInput = $event;
          })("click", function AutoCompleteComponent_div_0_Template_input_click_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r27);

            var ctx_r28 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

            return ctx_r28.searchinputClickCallback($event);
          })("keyup", function AutoCompleteComponent_div_0_Template_input_keyup_3_listener($event) {
            _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵrestoreView"](_r27);

            var ctx_r29 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

            return ctx_r29.searchinputCallback($event);
          });

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](4, AutoCompleteComponent_div_0_button_4_Template, 3, 2, "button", 6);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](5, AutoCompleteComponent_div_0_pre_5_Template, 2, 0, "pre", 7);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](6, AutoCompleteComponent_div_0_ul_6_Template, 5, 4, "ul", 8);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r0 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](2);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngClass", _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpureFunction1"](6, _c2, ctx_r0.settings.showSearchButton));

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵpropertyInterpolate"]("placeholder", ctx_r0.settings.inputPlaceholderText);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngModel", ctx_r0.locationInput);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r0.settings.showSearchButton);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r0.gettingCurrentLocationFlag);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx_r0.dropdownOpen && (ctx_r0.settings.showCurrentLocation || ctx_r0.queryItems.length));
        }
      }

      function AutoCompleteComponent_div_1_Template(rf, ctx) {
        if (rf & 1) {
          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementStart"](0, "div", 38);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtext"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵelementEnd"]();
        }

        if (rf & 2) {
          var ctx_r1 = _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵnextContext"]();

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

          _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtextInterpolate"](ctx_r1.settingsErrorMsg);
        }
      }

      var _AutoCompleteComponent = function () {
        function AutoCompleteComponent(platformId, _elmRef, _global, _autoCompleteSearchService) {
          this.platformId = platformId;
          this._elmRef = _elmRef;
          this._global = _global;
          this._autoCompleteSearchService = _autoCompleteSearchService;
          this.componentCallback = new _angular_core__WEBPACK_IMPORTED_MODULE_2__.EventEmitter();
          this.locationInput = '';
          this.gettingCurrentLocationFlag = false;
          this.dropdownOpen = false;
          this.recentDropdownOpen = false;
          this.queryItems = [];
          this.isSettingsError = false;
          this.settingsErrorMsg = '';
          this.settings = {};
          this.moduleinit = false;
          this.selectedDataIndex = -1;
          this.recentSearchData = [];
          this.userSelectedOption = '';
          this.defaultSettings = {
            geoPredictionServerUrl: '',
            geoLatLangServiceUrl: '',
            geoLocDetailServerUrl: '',
            geoCountryRestriction: [],
            geoTypes: [],
            geoLocation: [],
            geoRadius: 0,
            serverResponseListHierarchy: [],
            serverResponseatLangHierarchy: [],
            serverResponseDetailHierarchy: [],
            resOnSearchButtonClickOnly: false,
            useGoogleGeoApi: true,
            inputPlaceholderText: 'Enter Area Name',
            inputString: '',
            showSearchButton: true,
            showRecentSearch: true,
            showCurrentLocation: true,
            recentStorageName: 'recentSearches',
            noOfRecentSearchSave: 5,
            currentLocIconUrl: '',
            searchIconUrl: '',
            locationIconUrl: ''
          };
        }

        AutoCompleteComponent.prototype.ngOnInit = function () {
          if (!this.moduleinit) {
            this.moduleInit();
          }
        };

        AutoCompleteComponent.prototype.ngOnChanges = function () {
          this.moduleinit = true;
          this.moduleInit();
        }; //function called when click event happens in input box. (Binded with view)


        AutoCompleteComponent.prototype.searchinputClickCallback = function (event) {
          event.target.select();
          this.searchinputCallback(event);
        }; //function called when there is a change in input. (Binded with view)


        AutoCompleteComponent.prototype.searchinputCallback = function (event) {
          var inputVal = this.locationInput;

          if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            this.navigateInList(event.keyCode);
          } else if (inputVal) {
            this.getListQuery(inputVal);
          } else {
            this.queryItems = [];

            if (this.userSelectedOption) {
              this.userQuerySubmit('false');
            }

            this.userSelectedOption = '';

            if (this.settings.showRecentSearch) {
              this.showRecentSearch();
            } else {
              this.dropdownOpen = false;
            }
          }
        }; //function to execute when user hover over autocomplete list.(binded with view)


        AutoCompleteComponent.prototype.activeListNode = function (index) {
          for (var i = 0; i < this.queryItems.length; i++) {
            if (index === i) {
              this.queryItems[i].active = true;
              this.selectedDataIndex = index;
            } else {
              this.queryItems[i].active = false;
            }
          }
        }; //function to execute when user select the autocomplete list.(binded with view)


        AutoCompleteComponent.prototype.selectedListNode = function (index) {
          this.dropdownOpen = false;

          if (this.recentDropdownOpen) {
            this.setRecentLocation(this.queryItems[index]);
          } else {
            this.getPlaceLocationInfo(this.queryItems[index]);
          }
        }; //function to close the autocomplete list when clicked outside. (binded with view)


        AutoCompleteComponent.prototype.closeAutocomplete = function (event) {
          if (!this._elmRef.nativeElement.contains(event.target)) {
            this.selectedDataIndex = -1;
            this.dropdownOpen = false;
          }
        }; //function to manually trigger the callback to parent component when clicked search button.


        AutoCompleteComponent.prototype.userQuerySubmit = function (selectedOption) {
          var _userOption = selectedOption === 'false' ? '' : this.userSelectedOption;

          if (_userOption) {
            this.componentCallback.emit({
              'response': true,
              'data': this.userSelectedOption
            });
          } else {
            this.componentCallback.emit({
              'response': false,
              'reason': 'No user input'
            });
          }
        }; //function to get user current location from the device.


        AutoCompleteComponent.prototype.currentLocationSelected = function () {
          var _this = this;

          if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(this.platformId)) {
            this.gettingCurrentLocationFlag = true;
            this.dropdownOpen = false;

            this._autoCompleteSearchService.getGeoCurrentLocation().then(function (result) {
              if (!result) {
                _this.gettingCurrentLocationFlag = false;

                _this.componentCallback.emit({
                  'response': false,
                  'reason': 'Failed to get geo location'
                });
              } else {
                _this.getCurrentLocationInfo(result);
              }
            });
          }
        }; //module initialization happens. function called by ngOninit and ngOnChange


        AutoCompleteComponent.prototype.moduleInit = function () {
          this.settings = this.setUserSettings(); //condition to check if Radius is set without location detail.

          if (this.settings.geoRadius) {
            if (this.settings.geoLocation.length !== 2) {
              this.isSettingsError = true;
              this.settingsErrorMsg = this.settingsErrorMsg + 'Radius should be used with GeoLocation. Please use "geoLocation" key to set lat and lng. ';
            }
          } //condition to check if lat and lng is set and radious is not set then it will set to 20,000KM by default


          if (this.settings.geoLocation.length === 2 && !this.settings.geoRadius) {
            this.settings.geoRadius = 20000000;
          }

          if (this.settings.showRecentSearch) {
            this.getRecentLocations();
          }

          if (!this.settings.useGoogleGeoApi) {
            if (!this.settings.geoPredictionServerUrl) {
              this.isSettingsError = true;
              this.settingsErrorMsg = this.settingsErrorMsg + 'Prediction custom server url is not defined. Please use "geoPredictionServerUrl" key to set. ';
            }

            if (!this.settings.geoLatLangServiceUrl) {
              this.isSettingsError = true;
              this.settingsErrorMsg = this.settingsErrorMsg + 'Latitude and longitude custom server url is not defined. Please use "geoLatLangServiceUrl" key to set. ';
            }

            if (!this.settings.geoLocDetailServerUrl) {
              this.isSettingsError = true;
              this.settingsErrorMsg = this.settingsErrorMsg + 'Location detail custom server url is not defined. Please use "geoLocDetailServerUrl" key to set. ';
            }
          }

          this.locationInput = this.settings.inputString;
        }; //function to process the search query when pressed enter.


        AutoCompleteComponent.prototype.processSearchQuery = function () {
          if (this.queryItems.length) {
            if (this.selectedDataIndex > -1) {
              this.selectedListNode(this.selectedDataIndex);
            } else {
              this.selectedListNode(0);
            }
          }
        }; //function to set user settings if it is available.


        AutoCompleteComponent.prototype.setUserSettings = function () {
          var _tempObj = {};

          if (this.userSettings && typeof this.userSettings === 'object') {
            var keys = Object.keys(this.defaultSettings);

            for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
              var value = keys_1[_i];
              _tempObj[value] = this.userSettings[value] !== undefined ? this.userSettings[value] : this.defaultSettings[value];
            }

            return _tempObj;
          } else {
            return this.defaultSettings;
          }
        }; //function to get the autocomplete list based on user input.


        AutoCompleteComponent.prototype.getListQuery = function (value) {
          var _this = this;

          this.recentDropdownOpen = false;

          if (this.settings.useGoogleGeoApi) {
            var _tempParams = {
              'query': value,
              'countryRestriction': this.settings.geoCountryRestriction,
              'geoTypes': this.settings.geoTypes
            };

            if (this.settings.geoLocation.length === 2) {
              _tempParams.geoLocation = this.settings.geoLocation;
              _tempParams.radius = this.settings.geoRadius;
            }

            this._autoCompleteSearchService.getGeoPrediction(_tempParams).then(function (result) {
              _this.updateListItem(result);
            });
          } else {
            this._autoCompleteSearchService.getPredictions(this.settings.geoPredictionServerUrl, value).then(function (result) {
              result = _this.extractServerList(_this.settings.serverResponseListHierarchy, result);

              _this.updateListItem(result);
            });
          }
        }; //function to extratc custom data which is send by the server.


        AutoCompleteComponent.prototype.extractServerList = function (arrayList, data) {
          if (arrayList.length) {
            var _tempData = data;

            for (var _i = 0, arrayList_1 = arrayList; _i < arrayList_1.length; _i++) {
              var key = arrayList_1[_i];
              _tempData = _tempData[key];
            }

            return _tempData;
          } else {
            return data;
          }
        }; //function to update the predicted list.


        AutoCompleteComponent.prototype.updateListItem = function (listData) {
          this.queryItems = listData ? listData : [];
          this.dropdownOpen = true;
        }; //function to show the recent search result.


        AutoCompleteComponent.prototype.showRecentSearch = function () {
          var _this = this;

          this.recentDropdownOpen = true;
          this.dropdownOpen = true;

          this._autoCompleteSearchService.getRecentList(this.settings.recentStorageName).then(function (result) {
            if (result) {
              _this.queryItems = result;
            } else {
              _this.queryItems = [];
            }
          });
        }; //function to navigate through list when up and down keyboard key is pressed;


        AutoCompleteComponent.prototype.navigateInList = function (keyCode) {
          var arrayIndex = 0; //arrow down

          if (keyCode === 40) {
            if (this.selectedDataIndex >= 0) {
              arrayIndex = this.selectedDataIndex + 1 <= this.queryItems.length - 1 ? this.selectedDataIndex + 1 : 0;
            }

            this.activeListNode(arrayIndex);
          } else if (keyCode === 38) {
            if (this.selectedDataIndex >= 0) {
              arrayIndex = this.selectedDataIndex - 1 >= 0 ? this.selectedDataIndex - 1 : this.queryItems.length - 1;
            } else {
              arrayIndex = this.queryItems.length - 1;
            }

            this.activeListNode(arrayIndex);
          } else {
            this.processSearchQuery();
          }
        }; //function to execute to get location detail based on latitude and longitude.


        AutoCompleteComponent.prototype.getCurrentLocationInfo = function (latlng) {
          var _this = this;

          if (this.settings.useGoogleGeoApi) {
            this._autoCompleteSearchService.getGeoLatLngDetail(latlng).then(function (result) {
              if (result) {
                _this.setRecentLocation(result);
              }

              _this.gettingCurrentLocationFlag = false;
            });
          } else {
            this._autoCompleteSearchService.getLatLngDetail(this.settings.geoLatLangServiceUrl, latlng.lat, latlng.lng).then(function (result) {
              if (result) {
                result = _this.extractServerList(_this.settings.serverResponseatLangHierarchy, result);

                _this.setRecentLocation(result);
              }

              _this.gettingCurrentLocationFlag = false;
            });
          }
        }; //function to retrive the location info based on goovle place id.


        AutoCompleteComponent.prototype.getPlaceLocationInfo = function (selectedData) {
          var _this = this;

          if (this.settings.useGoogleGeoApi) {
            this._autoCompleteSearchService.getGeoPlaceDetail(selectedData.place_id).then(function (data) {
              if (data) {
                _this.setRecentLocation(data);
              }
            });
          } else {
            this._autoCompleteSearchService.getPlaceDetails(this.settings.geoLocDetailServerUrl, selectedData.place_id).then(function (result) {
              if (result) {
                result = _this.extractServerList(_this.settings.serverResponseDetailHierarchy, result);

                _this.setRecentLocation(result);
              }
            });
          }
        }; //function to store the selected user search in the localstorage.


        AutoCompleteComponent.prototype.setRecentLocation = function (data) {
          data = JSON.parse(JSON.stringify(data));
          data.description = data.description ? data.description : data.formatted_address;
          data.active = false;
          this.selectedDataIndex = -1;
          this.locationInput = data.description;

          if (this.settings.showRecentSearch) {
            this._autoCompleteSearchService.addRecentList(this.settings.recentStorageName, data, this.settings.noOfRecentSearchSave);

            this.getRecentLocations();
          }

          this.userSelectedOption = data; //below code will execute only when user press enter or select any option selection and it emit a callback to the parent component.

          if (!this.settings.resOnSearchButtonClickOnly) {
            this.componentCallback.emit({
              'response': true,
              'data': data
            });
          }
        }; //function to retrive the stored recent user search from the localstorage.


        AutoCompleteComponent.prototype.getRecentLocations = function () {
          var _this = this;

          this._autoCompleteSearchService.getRecentList(this.settings.recentStorageName).then(function (data) {
            _this.recentSearchData = data && data.length ? data : [];
          });
        };
        /** @nocollapse */


        AutoCompleteComponent.ctorParameters = function () {
          return [{
            type: Object,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
              args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_ID]
            }]
          }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
          }, {
            type: _windowRef_service__WEBPACK_IMPORTED_MODULE_0__.GlobalRef
          }, {
            type: _auto_complete_service__WEBPACK_IMPORTED_MODULE_1__.AutoCompleteSearchService
          }];
        };

        AutoCompleteComponent.propDecorators = {
          userSettings: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
          }],
          componentCallback: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
          }]
        };

        AutoCompleteComponent.ɵfac = function AutoCompleteComponent_Factory(t) {
          return new (t || AutoCompleteComponent)(_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_windowRef_service__WEBPACK_IMPORTED_MODULE_0__.GlobalRef), _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdirectiveInject"](_auto_complete_service__WEBPACK_IMPORTED_MODULE_1__.AutoCompleteSearchService));
        };

        AutoCompleteComponent.ɵcmp = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵdefineComponent"]({
          type: AutoCompleteComponent,
          selectors: [["ngxgeo-autocomplete"]],
          hostBindings: function AutoCompleteComponent_HostBindings(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵlistener"]("click", function AutoCompleteComponent_click_HostBindingHandler($event) {
                return ctx.closeAutocomplete($event);
              }, false, _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵresolveDocument"]);
            }
          },
          inputs: {
            userSettings: "userSettings"
          },
          outputs: {
            componentCallback: "componentCallback"
          },
          features: [_angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵNgOnChangesFeature"]],
          decls: 2,
          vars: 2,
          consts: [["class", "custom-autocomplete", 4, "ngIf"], ["class", "custom-autocomplete--error", 4, "ngIf"], [1, "custom-autocomplete"], [1, "custom-autocomplete__container"], [1, "custom-autocomplete__input", 3, "ngClass"], ["type", "search", "name", "search", "id", "search_places", "autocomplete", "off", 3, "ngModel", "placeholder", "ngModelChange", "click", "keyup"], ["class", "search-icon", 3, "click", 4, "ngIf"], ["class", "custom-autocomplete__loader", 4, "ngIf"], ["class", "custom-autocomplete__dropdown", 4, "ngIf"], [1, "search-icon", 3, "click"], [3, "ngStyle", 4, "ngIf"], ["class", "search-default-icon", 4, "ngIf"], [3, "ngStyle"], [1, "search-default-icon"], [1, "custom-autocomplete__loader"], [1, "gif"], [1, "custom-autocomplete__dropdown"], ["class", "currentlocation", 4, "ngIf"], ["class", "heading heading-recent", 4, "ngIf"], [3, "ngClass", 4, "ngFor", "ngForOf"], [1, "currentlocation"], ["href", "javascript:;", 3, "click"], ["class", "location-icon", 3, "ngStyle", 4, "ngIf"], ["class", "location-icon current-default-icon", 4, "ngIf"], [1, "location-icon", 3, "ngStyle"], [1, "location-icon", "current-default-icon"], [1, "heading", "heading-recent"], [1, "line", "line-location"], [1, "line", "line-recent"], [3, "ngClass"], ["href", "javascript:;", 3, "mouseover", "click"], ["class", "custom-icon", 3, "ngStyle", 4, "ngIf"], ["class", "custom-icon location-default-icon", 4, "ngIf"], [1, "main-text"], ["class", "secondary_text", 4, "ngIf"], [1, "custom-icon", 3, "ngStyle"], [1, "custom-icon", "location-default-icon"], [1, "secondary_text"], [1, "custom-autocomplete--error"]],
          template: function AutoCompleteComponent_Template(rf, ctx) {
            if (rf & 1) {
              _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](0, AutoCompleteComponent_div_0_Template, 7, 8, "div", 0);

              _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵtemplate"](1, AutoCompleteComponent_div_1_Template, 2, 1, "div", 1);
            }

            if (rf & 2) {
              _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", !ctx.isSettingsError);

              _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵadvance"](1);

              _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵɵproperty"]("ngIf", ctx.isSettingsError);
            }
          },
          directives: [_angular_common__WEBPACK_IMPORTED_MODULE_3__.NgIf, _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgClass, _angular_forms__WEBPACK_IMPORTED_MODULE_4__.DefaultValueAccessor, _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NgControlStatus, _angular_forms__WEBPACK_IMPORTED_MODULE_4__.NgModel, _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgStyle, _angular_common__WEBPACK_IMPORTED_MODULE_3__.NgForOf],
          styles: [".custom-autocomplete[_ngcontent-%COMP%] {\n      display: block;\n      position: relative;\n      width: 100%;\n      float: left;\n    }\n\n    .custom-autocomplete[_ngcontent-%COMP%]   a[_ngcontent-%COMP%], .custom-autocomplete[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover {\n      text-decoration: none;\n    }\n\n    .custom-autocomplete--error[_ngcontent-%COMP%] {\n      color: #fff;\n      background-color: #fd4f4f;\n      padding: 10px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%] {\n      position: absolute;\n      background: #fff;\n      margin: 0;\n      padding: 0;\n      width: 100%;\n      list-style: none;\n      border: 1px solid #909090;\n      z-index: 99;\n      top: 50px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   li[_ngcontent-%COMP%] {\n      float: left;\n      width: 100%;\n      font-size: 15px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   a[_ngcontent-%COMP%] {\n      width: 100%;\n      color: #353535;\n      float: left;\n      padding: 8px 10px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover {\n      text-decoration: none;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .currentlocation[_ngcontent-%COMP%] {\n      text-transform: uppercase;\n      letter-spacing: 1px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .currentlocation[_ngcontent-%COMP%]   a[_ngcontent-%COMP%] {\n      padding: 10px 10px 10px 13px;\n      font-size: 14px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .currentlocation[_ngcontent-%COMP%]   a[_ngcontent-%COMP%]:hover {\n      background-color: #eeeded;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .currentlocation[_ngcontent-%COMP%]   .location-icon[_ngcontent-%COMP%] {\n      width: 16px;\n      height: 16px;\n      background-size: cover;\n      background-image: url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDg3Ljg1OSA4Ny44NTkiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDg3Ljg1OSA4Ny44NTk7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8ZyBpZD0iTWFya2VyIj4KCQk8Zz4KCQkJPHBhdGggZD0iTTgwLjkzOCw0MC40ODNDNzkuMjk0LDIyLjcxMyw2NS4wOTMsOC41MjgsNDcuMzEyLDYuOTE3VjBoLTYuNzU3djYuOTE4QzIyLjc3Myw4LjUyOCw4LjU3MiwyMi43MTQsNi45Myw0MC40ODNIMHY2Ljc1NyAgICAgaDYuOTE5YzEuNTgyLDE3LjgzOCwxNS44MSwzMi4wODcsMzMuNjM2LDMzLjcwMXY2LjkxOGg2Ljc1N3YtNi45MThjMTcuODI2LTEuNjEzLDMyLjA1NC0xNS44NjIsMzMuNjM2LTMzLjcwMWg2LjkxMXYtNi43NTcgICAgIEg4MC45Mzh6IE00Ny4zMTIsNzQuMTQ2di02LjU1OGgtNi43NTd2Ni41NThDMjYuNDU3LDcyLjU4LDE1LjI0Miw2MS4zNDUsMTMuNzA4LDQ3LjI0aDYuNTY2di02Ljc1N2gtNi41NDkgICAgIGMxLjU5MS0xNC4wNDEsMTIuNzc3LTI1LjIxLDI2LjgyOS0yNi43NzF2Ni41NjRoNi43NTZ2LTYuNTY0YzE0LjA1MywxLjU2LDI1LjIzOSwxMi43MjksMjYuODMsMjYuNzcxaC02LjU1NnY2Ljc1N2g2LjU3MyAgICAgQzcyLjYyNSw2MS4zNDUsNjEuNDA5LDcyLjU4LDQ3LjMxMiw3NC4xNDZ6IE00My45MzQsMzMuNzI3Yy01LjU5NSwwLTEwLjEzNSw0LjUzMy0xMC4xMzUsMTAuMTMxICAgICBjMCw1LjU5OSw0LjU0LDEwLjEzOSwxMC4xMzUsMTAuMTM5czEwLjEzNC00LjU0LDEwLjEzNC0xMC4xMzlDNTQuMDY4LDM4LjI2LDQ5LjUyNywzMy43MjcsNDMuOTM0LDMzLjcyN3oiIGZpbGw9IiMwMDAwMDAiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==);\n      float: left;\n      margin-right: 10px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .heading[_ngcontent-%COMP%] {\n      padding: 13px 10px 7px 13px;\n      text-transform: uppercase;\n      letter-spacing: 1px;\n      font-size: 13px;\n      position: relative;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .heading[_ngcontent-%COMP%]   .line[_ngcontent-%COMP%] {\n      border-top: 1px solid #c2c2c2;\n      width: calc(100% - 115px);\n      display: inline-block;\n      position: absolute;\n      top: 21px;\n      left: 100px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .heading[_ngcontent-%COMP%]   .line-location[_ngcontent-%COMP%] {\n      left: 100px;\n      top: 16px;\n      width: calc(100% - 110px);\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .heading[_ngcontent-%COMP%]   .line-recent[_ngcontent-%COMP%] {\n      left: 158px;\n      top: 16px;\n      width: calc(100% - 168px);\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .heading-recent[_ngcontent-%COMP%] {\n      padding-top: 8px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .custom-icon[_ngcontent-%COMP%] {\n      width: 16px;\n      height: 16px;\n      background-size: cover;\n      vertical-align: bottom;\n      display: inline-block;\n      margin-right: 4px;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .main-text[_ngcontent-%COMP%] {\n      padding-right: 4px;\n      font-weight: 700;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .secondary_text[_ngcontent-%COMP%] {\n      font-size: 12px;\n      color: #909090;\n    }\n\n    .custom-autocomplete__dropdown[_ngcontent-%COMP%]   .active[_ngcontent-%COMP%]   a[_ngcontent-%COMP%] {\n      background-color: #ffe0cd;\n    }\n\n    .custom-autocomplete__loader[_ngcontent-%COMP%] {\n      position: absolute;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      text-align: center;\n      background: white;\n    }\n\n    .custom-autocomplete__loader[_ngcontent-%COMP%]   .gif[_ngcontent-%COMP%] {\n      background-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIiBjbGFzcz0idWlsLXJpcHBsZSI+PHBhdGggZmlsbD0ibm9uZSIgY2xhc3M9ImJrIiBkPSJNMCAwaDEwMHYxMDBIMHoiLz48Zz48YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiBkdXI9IjJzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgYmVnaW49IjBzIiBrZXlUaW1lcz0iMDswLjMzOzEiIHZhbHVlcz0iMTsxOzAiLz48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0MCIgc3Ryb2tlPSIjYWZhZmI3IiBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgZHVyPSIycyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGJlZ2luPSIwcyIga2V5VGltZXM9IjA7MC4zMzsxIiB2YWx1ZXM9IjA7MjI7NDQiLz48L2NpcmNsZT48L2c+PGc+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgZHVyPSIycyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGJlZ2luPSIxcyIga2V5VGltZXM9IjA7MC4zMzsxIiB2YWx1ZXM9IjE7MTswIi8+PGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDAiIHN0cm9rZT0iI2ZmYTYzMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InIiIGR1cj0iMnMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBiZWdpbj0iMXMiIGtleVRpbWVzPSIwOzAuMzM7MSIgdmFsdWVzPSIwOzIyOzQ0Ii8+PC9jaXJjbGU+PC9nPjwvc3ZnPg==);\n      background-size: cover;\n      width: 30px;\n      height: 30px;\n      top: 50%;\n      left: 50%;\n      transform: translate3d(-50%, -50%, 0);\n      position: absolute;\n    }\n\n    .custom-autocomplete__container[_ngcontent-%COMP%], .custom-autocomplete__input[_ngcontent-%COMP%] {\n      width: inherit;\n      float: inherit;\n      position: relative;\n    }\n\n    .custom-autocomplete__input[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n      margin: 0;\n      padding: 10px;\n      height: 50px;\n      border: 1px solid #ccc;\n      display: block;\n      width: 100%;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      font-size: 16px;\n\n    &\n    ::-webkit-input-placeholder {\n      color: #868484;\n    }\n\n    &\n    :-moz-placeholder { \n      color: #868484;\n    }\n\n    &\n    ::-moz-placeholder { \n      color: #868484;\n    }\n\n    &\n    :-ms-input-placeholder {\n      color: #868484;\n    }\n\n    }\n\n    .button-included[_ngcontent-%COMP%]   input[_ngcontent-%COMP%] {\n      padding-right: 60px;\n    }\n\n    .search-icon[_ngcontent-%COMP%] {\n      position: absolute;\n      right: 0;\n      width: 55px;\n      top: 0;\n      height: 100%;\n      background-color: transparent;\n      border-bottom: 0;\n      border-top: 0;\n      border-right: 0;\n      border-left: 1px solid #ccc;\n    }\n\n    .search-icon[_ngcontent-%COMP%]   i[_ngcontent-%COMP%] {\n      background-size: cover;\n      height: 23px;\n      width: 23px;\n      display: inline-block;\n    }\n\n    .search-default-icon[_ngcontent-%COMP%] {\n      background-image: url('data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDU2Ljk2NiA1Ni45NjYiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDU2Ljk2NiA1Ni45NjY7IiB4bWw6c3BhY2U9InByZXNlcnZlIiB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxNnB4Ij4KPHBhdGggZD0iTTU1LjE0Niw1MS44ODdMNDEuNTg4LDM3Ljc4NmMzLjQ4Ni00LjE0NCw1LjM5Ni05LjM1OCw1LjM5Ni0xNC43ODZjMC0xMi42ODItMTAuMzE4LTIzLTIzLTIzcy0yMywxMC4zMTgtMjMsMjMgIHMxMC4zMTgsMjMsMjMsMjNjNC43NjEsMCw5LjI5OC0xLjQzNiwxMy4xNzctNC4xNjJsMTMuNjYxLDE0LjIwOGMwLjU3MSwwLjU5MywxLjMzOSwwLjkyLDIuMTYyLDAuOTIgIGMwLjc3OSwwLDEuNTE4LTAuMjk3LDIuMDc5LTAuODM3QzU2LjI1NSw1NC45ODIsNTYuMjkzLDUzLjA4LDU1LjE0Niw1MS44ODd6IE0yMy45ODQsNmM5LjM3NCwwLDE3LDcuNjI2LDE3LDE3cy03LjYyNiwxNy0xNywxNyAgcy0xNy03LjYyNi0xNy0xN1MxNC42MSw2LDIzLjk4NCw2eiIgZmlsbD0iIzAwMDAwMCIvPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8L3N2Zz4K');\n    }\n\n    .location-default-icon[_ngcontent-%COMP%] {\n      background-image: url('data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4Ny43MjQgNDg3LjcyNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDg3LjcyNCA0ODcuNzI0OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCI+CjxnPgoJPGc+CgkJPHBhdGggZD0iTTIzNi45MjUsMC4xMjRjLTk2LjksMy40LTE3Ny40LDc5LTE4Ni43LDE3NS41Yy0xLjksMTkuMy0wLjgsMzgsMi42LDU1LjlsMCwwYzAsMCwwLjMsMi4xLDEuMyw2LjEgICAgYzMsMTMuNCw3LjUsMjYuNCwxMy4xLDM4LjZjMTkuNSw0Ni4yLDY0LjYsMTIzLjUsMTY1LjgsMjA3LjZjNi4yLDUuMiwxNS4zLDUuMiwyMS42LDBjMTAxLjItODQsMTQ2LjMtMTYxLjMsMTY1LjktMjA3LjcgICAgYzUuNy0xMi4yLDEwLjEtMjUuMSwxMy4xLTM4LjZjMC45LTMuOSwxLjMtNi4xLDEuMy02LjFsMCwwYzIuMy0xMiwzLjUtMjQuMywzLjUtMzYuOUM0MzguNDI1LDg0LjcyNCwzNDcuNTI1LTMuNzc2LDIzNi45MjUsMC4xMjQgICAgeiBNMjQzLjgyNSwyOTEuMzI0Yy01Mi4yLDAtOTQuNS00Mi4zLTk0LjUtOTQuNXM0Mi4zLTk0LjUsOTQuNS05NC41czk0LjUsNDIuMyw5NC41LDk0LjVTMjk2LjAyNSwyOTEuMzI0LDI0My44MjUsMjkxLjMyNHoiIGZpbGw9IiMwMDAwMDAiLz4KCTwvZz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8L3N2Zz4K');\n    }\n\n    .current-default-icon[_ngcontent-%COMP%] {\n      background-image: url('data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDg3Ljg1OSA4Ny44NTkiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDg3Ljg1OSA4Ny44NTk7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8ZyBpZD0iTWFya2VyIj4KCQk8Zz4KCQkJPHBhdGggZD0iTTgwLjkzOCw0MC40ODNDNzkuMjk0LDIyLjcxMyw2NS4wOTMsOC41MjgsNDcuMzEyLDYuOTE3VjBoLTYuNzU3djYuOTE4QzIyLjc3Myw4LjUyOCw4LjU3MiwyMi43MTQsNi45Myw0MC40ODNIMHY2Ljc1NyAgICAgaDYuOTE5YzEuNTgyLDE3LjgzOCwxNS44MSwzMi4wODcsMzMuNjM2LDMzLjcwMXY2LjkxOGg2Ljc1N3YtNi45MThjMTcuODI2LTEuNjEzLDMyLjA1NC0xNS44NjIsMzMuNjM2LTMzLjcwMWg2LjkxMXYtNi43NTcgICAgIEg4MC45Mzh6IE00Ny4zMTIsNzQuMTQ2di02LjU1OGgtNi43NTd2Ni41NThDMjYuNDU3LDcyLjU4LDE1LjI0Miw2MS4zNDUsMTMuNzA4LDQ3LjI0aDYuNTY2di02Ljc1N2gtNi41NDkgICAgIGMxLjU5MS0xNC4wNDEsMTIuNzc3LTI1LjIxLDI2LjgyOS0yNi43NzF2Ni41NjRoNi43NTZ2LTYuNTY0YzE0LjA1MywxLjU2LDI1LjIzOSwxMi43MjksMjYuODMsMjYuNzcxaC02LjU1NnY2Ljc1N2g2LjU3MyAgICAgQzcyLjYyNSw2MS4zNDUsNjEuNDA5LDcyLjU4LDQ3LjMxMiw3NC4xNDZ6IE00My45MzQsMzMuNzI3Yy01LjU5NSwwLTEwLjEzNSw0LjUzMy0xMC4xMzUsMTAuMTMxICAgICBjMCw1LjU5OSw0LjU0LDEwLjEzOSwxMC4xMzUsMTAuMTM5czEwLjEzNC00LjU0LDEwLjEzNC0xMC4xMzlDNTQuMDY4LDM4LjI2LDQ5LjUyNywzMy43MjcsNDMuOTM0LDMzLjcyN3oiIGZpbGw9IiMwMDAwMDAiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==');\n    }\n\n    .custom-autocomplete__container[_ngcontent-%COMP%]   .searchpage[_ngcontent-%COMP%] {\n      margin-top: 0;\n      padding: 0;\n      height: 55px;\n      border: none;\n    }"]
        });

        (function () {
          (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_2__["ɵsetClassMetadata"](AutoCompleteComponent, [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Component,
            args: [{
              selector: 'ngxgeo-autocomplete',
              template: "\n    <div class=\"custom-autocomplete\" *ngIf=\"!isSettingsError\">\n      <div class=\"custom-autocomplete__container\">\n        <div class=\"custom-autocomplete__input\" [ngClass]=\"{'button-included':settings.showSearchButton}\">\n          <input [(ngModel)]=\"locationInput\" (click)=\"searchinputClickCallback($event)\"\n                 (keyup)=\"searchinputCallback($event)\"\n                 type=\"search\" name=\"search\" id=\"search_places\" placeholder=\"{{settings.inputPlaceholderText}}\"\n                 autocomplete=\"off\">\n          <button class=\"search-icon\" *ngIf=\"settings.showSearchButton\" (click)=\"userQuerySubmit()\">\n            <i *ngIf=\"settings.searchIconUrl\"\n               [ngStyle]=\"{'background-image': 'url(' + settings.searchIconUrl + ')'}\"></i>\n            <i *ngIf=\"!settings.searchIconUrl\" class=\"search-default-icon\"></i>\n          </button>\n        </div>\n        <pre class=\"custom-autocomplete__loader\" *ngIf=\"gettingCurrentLocationFlag\"><i class=\"gif\"></i></pre>\n      </div>\n      <ul class=\"custom-autocomplete__dropdown\"\n          *ngIf=\"dropdownOpen && (settings.showCurrentLocation || queryItems.length)\">\n        <li *ngIf=\"settings.showCurrentLocation\" class=\"currentlocation\">\n          <a href=\"javascript:;\" (click)=\"currentLocationSelected()\">\n            <i class=\"location-icon\" *ngIf=\"settings.currentLocIconUrl\"\n               [ngStyle]=\"{'background-image': 'url(' + settings.currentLocIconUrl + ')'}\"></i>Use Current Location\n            <i class=\"location-icon current-default-icon\" *ngIf=\"!settings.currentLocIconUrl\"></i>\n          </a>\n        </li>\n        <li class=\"heading heading-recent\" *ngIf=\"!recentDropdownOpen && queryItems.length\"><span>Locations</span><span\n          class=\"line line-location\"></span></li>\n        <li class=\"heading heading-recent\" *ngIf=\"recentDropdownOpen && queryItems.length\">\n          <span>Recent Searches</span><span class=\"line line-recent\"></span>\n        </li>\n        <li *ngFor=\"let data of queryItems;let $index = index\" [ngClass]=\"{'active': data.active}\">\n          <a href=\"javascript:;\" (mouseover)=\"activeListNode($index)\" (click)=\"selectedListNode($index)\">\n            <i class=\"custom-icon\" *ngIf=\"settings.locationIconUrl\"\n               [ngStyle]=\"{'background-image': 'url(' + settings.locationIconUrl + ')'}\"></i>\n            <i class=\"custom-icon location-default-icon\" *ngIf=\"!settings.locationIconUrl\"></i>\n            <span class=\"main-text\">\n                {{data.structured_formatting?.main_text ? data.structured_formatting.main_text : data.description}}\n              </span>\n            <span class=\"secondary_text\"\n                  *ngIf=\"data.structured_formatting?.secondary_text\">{{data.structured_formatting.secondary_text}}</span>\n          </a>\n        </li>\n      </ul>\n    </div>\n    <div class=\"custom-autocomplete--error\" *ngIf=\"isSettingsError\">{{settingsErrorMsg}}</div>\n  ",
              styles: ["\n    .custom-autocomplete {\n      display: block;\n      position: relative;\n      width: 100%;\n      float: left;\n    }\n\n    .custom-autocomplete a, .custom-autocomplete a:hover {\n      text-decoration: none;\n    }\n\n    .custom-autocomplete--error {\n      color: #fff;\n      background-color: #fd4f4f;\n      padding: 10px;\n    }\n\n    .custom-autocomplete__dropdown {\n      position: absolute;\n      background: #fff;\n      margin: 0;\n      padding: 0;\n      width: 100%;\n      list-style: none;\n      border: 1px solid #909090;\n      z-index: 99;\n      top: 50px;\n    }\n\n    .custom-autocomplete__dropdown li {\n      float: left;\n      width: 100%;\n      font-size: 15px;\n    }\n\n    .custom-autocomplete__dropdown a {\n      width: 100%;\n      color: #353535;\n      float: left;\n      padding: 8px 10px;\n    }\n\n    .custom-autocomplete__dropdown a:hover {\n      text-decoration: none;\n    }\n\n    .custom-autocomplete__dropdown .currentlocation {\n      text-transform: uppercase;\n      letter-spacing: 1px;\n    }\n\n    .custom-autocomplete__dropdown .currentlocation a {\n      padding: 10px 10px 10px 13px;\n      font-size: 14px;\n    }\n\n    .custom-autocomplete__dropdown .currentlocation a:hover {\n      background-color: #eeeded;\n    }\n\n    .custom-autocomplete__dropdown .currentlocation .location-icon {\n      width: 16px;\n      height: 16px;\n      background-size: cover;\n      background-image: url(data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDg3Ljg1OSA4Ny44NTkiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDg3Ljg1OSA4Ny44NTk7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8ZyBpZD0iTWFya2VyIj4KCQk8Zz4KCQkJPHBhdGggZD0iTTgwLjkzOCw0MC40ODNDNzkuMjk0LDIyLjcxMyw2NS4wOTMsOC41MjgsNDcuMzEyLDYuOTE3VjBoLTYuNzU3djYuOTE4QzIyLjc3Myw4LjUyOCw4LjU3MiwyMi43MTQsNi45Myw0MC40ODNIMHY2Ljc1NyAgICAgaDYuOTE5YzEuNTgyLDE3LjgzOCwxNS44MSwzMi4wODcsMzMuNjM2LDMzLjcwMXY2LjkxOGg2Ljc1N3YtNi45MThjMTcuODI2LTEuNjEzLDMyLjA1NC0xNS44NjIsMzMuNjM2LTMzLjcwMWg2LjkxMXYtNi43NTcgICAgIEg4MC45Mzh6IE00Ny4zMTIsNzQuMTQ2di02LjU1OGgtNi43NTd2Ni41NThDMjYuNDU3LDcyLjU4LDE1LjI0Miw2MS4zNDUsMTMuNzA4LDQ3LjI0aDYuNTY2di02Ljc1N2gtNi41NDkgICAgIGMxLjU5MS0xNC4wNDEsMTIuNzc3LTI1LjIxLDI2LjgyOS0yNi43NzF2Ni41NjRoNi43NTZ2LTYuNTY0YzE0LjA1MywxLjU2LDI1LjIzOSwxMi43MjksMjYuODMsMjYuNzcxaC02LjU1NnY2Ljc1N2g2LjU3MyAgICAgQzcyLjYyNSw2MS4zNDUsNjEuNDA5LDcyLjU4LDQ3LjMxMiw3NC4xNDZ6IE00My45MzQsMzMuNzI3Yy01LjU5NSwwLTEwLjEzNSw0LjUzMy0xMC4xMzUsMTAuMTMxICAgICBjMCw1LjU5OSw0LjU0LDEwLjEzOSwxMC4xMzUsMTAuMTM5czEwLjEzNC00LjU0LDEwLjEzNC0xMC4xMzlDNTQuMDY4LDM4LjI2LDQ5LjUyNywzMy43MjcsNDMuOTM0LDMzLjcyN3oiIGZpbGw9IiMwMDAwMDAiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==);\n      float: left;\n      margin-right: 10px;\n    }\n\n    .custom-autocomplete__dropdown .heading {\n      padding: 13px 10px 7px 13px;\n      text-transform: uppercase;\n      letter-spacing: 1px;\n      font-size: 13px;\n      position: relative;\n    }\n\n    .custom-autocomplete__dropdown .heading .line {\n      border-top: 1px solid #c2c2c2;\n      width: calc(100% - 115px);\n      display: inline-block;\n      position: absolute;\n      top: 21px;\n      left: 100px;\n    }\n\n    .custom-autocomplete__dropdown .heading .line-location {\n      left: 100px;\n      top: 16px;\n      width: calc(100% - 110px);\n    }\n\n    .custom-autocomplete__dropdown .heading .line-recent {\n      left: 158px;\n      top: 16px;\n      width: calc(100% - 168px);\n    }\n\n    .custom-autocomplete__dropdown .heading-recent {\n      padding-top: 8px;\n    }\n\n    .custom-autocomplete__dropdown .custom-icon {\n      width: 16px;\n      height: 16px;\n      background-size: cover;\n      vertical-align: bottom;\n      display: inline-block;\n      margin-right: 4px;\n    }\n\n    .custom-autocomplete__dropdown .main-text {\n      padding-right: 4px;\n      font-weight: 700;\n    }\n\n    .custom-autocomplete__dropdown .secondary_text {\n      font-size: 12px;\n      color: #909090;\n    }\n\n    .custom-autocomplete__dropdown .active a {\n      background-color: #ffe0cd;\n    }\n\n    .custom-autocomplete__loader {\n      position: absolute;\n      top: 0;\n      width: 100%;\n      height: 100%;\n      text-align: center;\n      background: white;\n    }\n\n    .custom-autocomplete__loader .gif {\n      background-image: url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iMzAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDEwMCAxMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIiBjbGFzcz0idWlsLXJpcHBsZSI+PHBhdGggZmlsbD0ibm9uZSIgY2xhc3M9ImJrIiBkPSJNMCAwaDEwMHYxMDBIMHoiLz48Zz48YW5pbWF0ZSBhdHRyaWJ1dGVOYW1lPSJvcGFjaXR5IiBkdXI9IjJzIiByZXBlYXRDb3VudD0iaW5kZWZpbml0ZSIgYmVnaW49IjBzIiBrZXlUaW1lcz0iMDswLjMzOzEiIHZhbHVlcz0iMTsxOzAiLz48Y2lyY2xlIGN4PSI1MCIgY3k9IjUwIiByPSI0MCIgc3Ryb2tlPSIjYWZhZmI3IiBmaWxsPSJub25lIiBzdHJva2Utd2lkdGg9IjgiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCI+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0iciIgZHVyPSIycyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGJlZ2luPSIwcyIga2V5VGltZXM9IjA7MC4zMzsxIiB2YWx1ZXM9IjA7MjI7NDQiLz48L2NpcmNsZT48L2c+PGc+PGFuaW1hdGUgYXR0cmlidXRlTmFtZT0ib3BhY2l0eSIgZHVyPSIycyIgcmVwZWF0Q291bnQ9ImluZGVmaW5pdGUiIGJlZ2luPSIxcyIga2V5VGltZXM9IjA7MC4zMzsxIiB2YWx1ZXM9IjE7MTswIi8+PGNpcmNsZSBjeD0iNTAiIGN5PSI1MCIgcj0iNDAiIHN0cm9rZT0iI2ZmYTYzMyIgZmlsbD0ibm9uZSIgc3Ryb2tlLXdpZHRoPSI4IiBzdHJva2UtbGluZWNhcD0icm91bmQiPjxhbmltYXRlIGF0dHJpYnV0ZU5hbWU9InIiIGR1cj0iMnMiIHJlcGVhdENvdW50PSJpbmRlZmluaXRlIiBiZWdpbj0iMXMiIGtleVRpbWVzPSIwOzAuMzM7MSIgdmFsdWVzPSIwOzIyOzQ0Ii8+PC9jaXJjbGU+PC9nPjwvc3ZnPg==);\n      background-size: cover;\n      width: 30px;\n      height: 30px;\n      top: 50%;\n      left: 50%;\n      transform: translate3d(-50%, -50%, 0);\n      position: absolute;\n    }\n\n    .custom-autocomplete__container, .custom-autocomplete__input {\n      width: inherit;\n      float: inherit;\n      position: relative;\n    }\n\n    .custom-autocomplete__input input {\n      margin: 0;\n      padding: 10px;\n      height: 50px;\n      border: 1px solid #ccc;\n      display: block;\n      width: 100%;\n      overflow: hidden;\n      text-overflow: ellipsis;\n      font-size: 16px;\n\n    &\n    ::-webkit-input-placeholder {\n      color: #868484;\n    }\n\n    &\n    :-moz-placeholder { /* Firefox 18- */\n      color: #868484;\n    }\n\n    &\n    ::-moz-placeholder { /* Firefox 19+ */\n      color: #868484;\n    }\n\n    &\n    :-ms-input-placeholder {\n      color: #868484;\n    }\n\n    }\n\n    .button-included input {\n      padding-right: 60px;\n    }\n\n    .search-icon {\n      position: absolute;\n      right: 0;\n      width: 55px;\n      top: 0;\n      height: 100%;\n      background-color: transparent;\n      border-bottom: 0;\n      border-top: 0;\n      border-right: 0;\n      border-left: 1px solid #ccc;\n    }\n\n    .search-icon i {\n      background-size: cover;\n      height: 23px;\n      width: 23px;\n      display: inline-block;\n    }\n\n    .search-default-icon {\n      background-image: url('data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDU2Ljk2NiA1Ni45NjYiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDU2Ljk2NiA1Ni45NjY7IiB4bWw6c3BhY2U9InByZXNlcnZlIiB3aWR0aD0iMTZweCIgaGVpZ2h0PSIxNnB4Ij4KPHBhdGggZD0iTTU1LjE0Niw1MS44ODdMNDEuNTg4LDM3Ljc4NmMzLjQ4Ni00LjE0NCw1LjM5Ni05LjM1OCw1LjM5Ni0xNC43ODZjMC0xMi42ODItMTAuMzE4LTIzLTIzLTIzcy0yMywxMC4zMTgtMjMsMjMgIHMxMC4zMTgsMjMsMjMsMjNjNC43NjEsMCw5LjI5OC0xLjQzNiwxMy4xNzctNC4xNjJsMTMuNjYxLDE0LjIwOGMwLjU3MSwwLjU5MywxLjMzOSwwLjkyLDIuMTYyLDAuOTIgIGMwLjc3OSwwLDEuNTE4LTAuMjk3LDIuMDc5LTAuODM3QzU2LjI1NSw1NC45ODIsNTYuMjkzLDUzLjA4LDU1LjE0Niw1MS44ODd6IE0yMy45ODQsNmM5LjM3NCwwLDE3LDcuNjI2LDE3LDE3cy03LjYyNiwxNy0xNywxNyAgcy0xNy03LjYyNi0xNy0xN1MxNC42MSw2LDIzLjk4NCw2eiIgZmlsbD0iIzAwMDAwMCIvPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8L3N2Zz4K');\n    }\n\n    .location-default-icon {\n      background-image: url('data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTkuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQ4Ny43MjQgNDg3LjcyNCIgc3R5bGU9ImVuYWJsZS1iYWNrZ3JvdW5kOm5ldyAwIDAgNDg3LjcyNCA0ODcuNzI0OyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCI+CjxnPgoJPGc+CgkJPHBhdGggZD0iTTIzNi45MjUsMC4xMjRjLTk2LjksMy40LTE3Ny40LDc5LTE4Ni43LDE3NS41Yy0xLjksMTkuMy0wLjgsMzgsMi42LDU1LjlsMCwwYzAsMCwwLjMsMi4xLDEuMyw2LjEgICAgYzMsMTMuNCw3LjUsMjYuNCwxMy4xLDM4LjZjMTkuNSw0Ni4yLDY0LjYsMTIzLjUsMTY1LjgsMjA3LjZjNi4yLDUuMiwxNS4zLDUuMiwyMS42LDBjMTAxLjItODQsMTQ2LjMtMTYxLjMsMTY1LjktMjA3LjcgICAgYzUuNy0xMi4yLDEwLjEtMjUuMSwxMy4xLTM4LjZjMC45LTMuOSwxLjMtNi4xLDEuMy02LjFsMCwwYzIuMy0xMiwzLjUtMjQuMywzLjUtMzYuOUM0MzguNDI1LDg0LjcyNCwzNDcuNTI1LTMuNzc2LDIzNi45MjUsMC4xMjQgICAgeiBNMjQzLjgyNSwyOTEuMzI0Yy01Mi4yLDAtOTQuNS00Mi4zLTk0LjUtOTQuNXM0Mi4zLTk0LjUsOTQuNS05NC41czk0LjUsNDIuMyw5NC41LDk0LjVTMjk2LjAyNSwyOTEuMzI0LDI0My44MjUsMjkxLjMyNHoiIGZpbGw9IiMwMDAwMDAiLz4KCTwvZz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8Zz4KPC9nPgo8L3N2Zz4K');\n    }\n\n    .current-default-icon {\n      background-image: url('data:image/svg+xml;utf8;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iaXNvLTg4NTktMSI/Pgo8IS0tIEdlbmVyYXRvcjogQWRvYmUgSWxsdXN0cmF0b3IgMTYuMC4wLCBTVkcgRXhwb3J0IFBsdWctSW4gLiBTVkcgVmVyc2lvbjogNi4wMCBCdWlsZCAwKSAgLS0+CjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0iQ2FwYV8xIiB4PSIwcHgiIHk9IjBweCIgd2lkdGg9IjE2cHgiIGhlaWdodD0iMTZweCIgdmlld0JveD0iMCAwIDg3Ljg1OSA4Ny44NTkiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDg3Ljg1OSA4Ny44NTk7IiB4bWw6c3BhY2U9InByZXNlcnZlIj4KPGc+Cgk8ZyBpZD0iTWFya2VyIj4KCQk8Zz4KCQkJPHBhdGggZD0iTTgwLjkzOCw0MC40ODNDNzkuMjk0LDIyLjcxMyw2NS4wOTMsOC41MjgsNDcuMzEyLDYuOTE3VjBoLTYuNzU3djYuOTE4QzIyLjc3Myw4LjUyOCw4LjU3MiwyMi43MTQsNi45Myw0MC40ODNIMHY2Ljc1NyAgICAgaDYuOTE5YzEuNTgyLDE3LjgzOCwxNS44MSwzMi4wODcsMzMuNjM2LDMzLjcwMXY2LjkxOGg2Ljc1N3YtNi45MThjMTcuODI2LTEuNjEzLDMyLjA1NC0xNS44NjIsMzMuNjM2LTMzLjcwMWg2LjkxMXYtNi43NTcgICAgIEg4MC45Mzh6IE00Ny4zMTIsNzQuMTQ2di02LjU1OGgtNi43NTd2Ni41NThDMjYuNDU3LDcyLjU4LDE1LjI0Miw2MS4zNDUsMTMuNzA4LDQ3LjI0aDYuNTY2di02Ljc1N2gtNi41NDkgICAgIGMxLjU5MS0xNC4wNDEsMTIuNzc3LTI1LjIxLDI2LjgyOS0yNi43NzF2Ni41NjRoNi43NTZ2LTYuNTY0YzE0LjA1MywxLjU2LDI1LjIzOSwxMi43MjksMjYuODMsMjYuNzcxaC02LjU1NnY2Ljc1N2g2LjU3MyAgICAgQzcyLjYyNSw2MS4zNDUsNjEuNDA5LDcyLjU4LDQ3LjMxMiw3NC4xNDZ6IE00My45MzQsMzMuNzI3Yy01LjU5NSwwLTEwLjEzNSw0LjUzMy0xMC4xMzUsMTAuMTMxICAgICBjMCw1LjU5OSw0LjU0LDEwLjEzOSwxMC4xMzUsMTAuMTM5czEwLjEzNC00LjU0LDEwLjEzNC0xMC4xMzlDNTQuMDY4LDM4LjI2LDQ5LjUyNywzMy43MjcsNDMuOTM0LDMzLjcyN3oiIGZpbGw9IiMwMDAwMDAiLz4KCQk8L2c+Cgk8L2c+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPGc+CjwvZz4KPC9zdmc+Cg==');\n    }\n\n    .custom-autocomplete__container .searchpage {\n      margin-top: 0;\n      padding: 0;\n      height: 55px;\n      border: none;\n    }\n\n  "],
              host: {
                '(document:click)': 'closeAutocomplete($event)'
              }
            }]
          }], function () {
            return [{
              type: Object,
              decorators: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Inject,
                args: [_angular_core__WEBPACK_IMPORTED_MODULE_2__.PLATFORM_ID]
              }]
            }, {
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.ElementRef
            }, {
              type: _windowRef_service__WEBPACK_IMPORTED_MODULE_0__.GlobalRef
            }, {
              type: _auto_complete_service__WEBPACK_IMPORTED_MODULE_1__.AutoCompleteSearchService
            }];
          }, {
            componentCallback: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Output
            }],
            userSettings: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_2__.Input
            }]
          });
        })();

        return AutoCompleteComponent;
      }(); //# sourceMappingURL=auto-complete.component.js.map

      /***/

    },

    /***/
    16674: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "AutoCompleteSearchService": function AutoCompleteSearchService() {
          return (
            /* binding */
            _AutoCompleteSearchService
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! @angular/common */
      38583);
      /* harmony import */


      var _windowRef_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./windowRef.service */
      56313);
      /* harmony import */


      var _angular_common_http__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! @angular/common/http */
      91841);
      /* harmony import */


      var _storage_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./storage.service */
      32098);

      var _AutoCompleteSearchService = function () {
        function AutoCompleteSearchService(_http, platformId, _global, _localStorageService) {
          this._http = _http;
          this.platformId = platformId;
          this._global = _global;
          this._localStorageService = _localStorageService;
        }

        AutoCompleteSearchService.prototype.getPredictions = function (url, query) {
          var _this = this;

          return new Promise(function (resolve) {
            _this._http.get(url, {
              params: new _angular_common_http__WEBPACK_IMPORTED_MODULE_2__.HttpParams().set("query", query)
            }).subscribe(function (data) {
              if (data) {
                resolve(data);
              } else {
                resolve(false);
              }
            });
          });
        };

        AutoCompleteSearchService.prototype.getLatLngDetail = function (url, lat, lng) {
          var _this = this;

          return new Promise(function (resolve) {
            _this._http.get(url, {
              params: new _angular_common_http__WEBPACK_IMPORTED_MODULE_2__.HttpParams().set("lat", lat).set("lng", lng)
            }).subscribe(function (data) {
              if (data) {
                resolve(data);
              } else {
                resolve(false);
              }
            });
          });
        };

        AutoCompleteSearchService.prototype.getPlaceDetails = function (url, placeId) {
          var _this = this;

          return new Promise(function (resolve) {
            _this._http.get(url, {
              params: new _angular_common_http__WEBPACK_IMPORTED_MODULE_2__.HttpParams().set("query", placeId)
            }).subscribe(function (data) {
              if (data) {
                resolve(data);
              } else {
                resolve(false);
              }
            });
          });
        };

        AutoCompleteSearchService.prototype.getGeoCurrentLocation = function () {
          var _this = this;

          return new Promise(function (resolve) {
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(_this.platformId)) {
              var _window = _this._global.nativeGlobal;

              if (_window.navigator.geolocation) {
                _window.navigator.geolocation.getCurrentPosition(function (pos) {
                  var latlng = {
                    lat: parseFloat(pos.coords.latitude + ''),
                    lng: parseFloat(pos.coords.longitude + '')
                  };
                  resolve(latlng);
                }, function (error) {
                  resolve(false);
                });
              } else {
                resolve(false);
              }
            } else {
              resolve(false);
            }
          });
        };

        AutoCompleteSearchService.prototype.getGeoLatLngDetail = function (latlng) {
          var _this = this;

          return new Promise(function (resolve) {
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(_this.platformId)) {
              var _window = _this._global.nativeGlobal;
              var geocoder = new _window.google.maps.Geocoder();
              geocoder.geocode({
                'location': latlng
              }, function (results, status) {
                if (status === 'OK') {
                  _this.getGeoPlaceDetail(results[0].place_id).then(function (result) {
                    if (result) {
                      resolve(result);
                    } else {
                      resolve(false);
                    }
                  });
                } else {
                  resolve(false);
                }
              });
            } else {
              resolve(false);
            }
          });
        };

        AutoCompleteSearchService.prototype.getGeoPrediction = function (params) {
          var _this = this;

          return new Promise(function (resolve) {
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(_this.platformId)) {
              var _window = _this._global.nativeGlobal;
              var placesService = new _window.google.maps.places.AutocompleteService();
              var queryInput = {};
              var promiseArr = [];

              if (params.countryRestriction.length) {
                queryInput = {
                  input: params.query,
                  componentRestrictions: {
                    country: params.countryRestriction
                  }
                };
              } else {
                queryInput = {
                  input: params.query
                };
              }

              if (params.geoLocation) {
                queryInput.location = new _window.google.maps.LatLng(parseFloat(params.geoLocation[0]), parseFloat(params.geoLocation[1]));
                queryInput.radius = params.radius;
              }

              if (params.geoTypes.length) {
                for (var i = 0; i < params.geoTypes.length; i++) {
                  var _tempQuery = queryInput;
                  _tempQuery['types'] = new Array(params.geoTypes[i]);
                  promiseArr.push(_this.geoPredictionCall(placesService, _tempQuery));
                }
              } else {
                promiseArr.push(_this.geoPredictionCall(placesService, queryInput));
              }

              Promise.all(promiseArr).then(function (values) {
                var val = values;

                if (val.length > 1) {
                  var _tempArr = [];

                  for (var j = 0; j < val.length; j++) {
                    if (val[j] && val[j].length) {
                      _tempArr = _tempArr.concat(val[j]);
                    }
                  }

                  _tempArr = _this.getUniqueResults(_tempArr);
                  resolve(_tempArr);
                } else {
                  resolve(values[0]);
                }
              });
            } else {
              resolve(false);
            }
          });
        };

        AutoCompleteSearchService.prototype.getGeoPlaceDetail = function (placeId) {
          var _this = this;

          return new Promise(function (resolve) {
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(_this.platformId)) {
              var _window = _this._global.nativeGlobal;
              var placesService = new _window.google.maps.places.PlacesService(document.createElement('div'));
              placesService.getDetails({
                'placeId': placeId
              }, function (result, status) {
                if (result == null || result.length === 0) {
                  _this.getGeoPaceDetailByReferance(result.referance).then(function (referanceData) {
                    if (!referanceData) {
                      resolve(false);
                    } else {
                      resolve(referanceData);
                    }
                  });
                } else {
                  resolve(result);
                }
              });
            } else {
              resolve(false);
            }
          });
        };

        AutoCompleteSearchService.prototype.getGeoPaceDetailByReferance = function (referance) {
          var _this = this;

          return new Promise(function (resolve) {
            if ((0, _angular_common__WEBPACK_IMPORTED_MODULE_3__.isPlatformBrowser)(_this.platformId)) {
              var _window_1 = _this._global.nativeGlobal;
              var placesService = new _window_1.google.maps.places.PlacesService();
              placesService.getDetails({
                'reference': referance
              }, function (result, status) {
                if (status === _window_1.google.maps.places.PlacesServiceStatus.OK) {
                  resolve(result);
                } else {
                  resolve(false);
                }
              });
            } else {
              resolve(false);
            }
          });
        };

        AutoCompleteSearchService.prototype.addRecentList = function (localStorageName, result, itemSavedLength) {
          var _this = this;

          this.getRecentList(localStorageName).then(function (data) {
            if (data) {
              for (var i = 0; i < data.length; i++) {
                if (data[i].description === result.description) {
                  data.splice(i, 1);
                  break;
                }
              }

              data.unshift(result);

              if (data.length > itemSavedLength) {
                data.pop();
              }

              _this._localStorageService.setItem(localStorageName, JSON.stringify(data));
            }
          });
        };

        AutoCompleteSearchService.prototype.getRecentList = function (localStorageName) {
          var _this = this;

          return new Promise(function (resolve) {
            var value = _this._localStorageService.getItem(localStorageName);

            if (value) {
              value = JSON.parse(value);
            } else {
              value = [];
            }

            resolve(value);
          });
        };

        AutoCompleteSearchService.prototype.getUniqueResults = function (arr) {
          return Array.from(arr.reduce(function (m, t) {
            return m.set(t.place_id, t);
          }, new Map()).values());
        };

        AutoCompleteSearchService.prototype.geoPredictionCall = function (placesService, queryInput) {
          var _window = this._global.nativeGlobal;
          return new Promise(function (resolve) {
            placesService.getPlacePredictions(queryInput, function (result, status) {
              if (status === _window.google.maps.places.PlacesServiceStatus.OK) {
                resolve(result);
              } else {
                resolve(false);
              }
            });
          });
        };
        /** @nocollapse */


        AutoCompleteSearchService.ctorParameters = function () {
          return [{
            type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__.HttpClient
          }, {
            type: Object,
            decorators: [{
              type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
              args: [_angular_core__WEBPACK_IMPORTED_MODULE_4__.PLATFORM_ID]
            }]
          }, {
            type: _windowRef_service__WEBPACK_IMPORTED_MODULE_0__.GlobalRef
          }, {
            type: _storage_service__WEBPACK_IMPORTED_MODULE_1__.LocalStorageService
          }];
        };

        AutoCompleteSearchService.ɵfac = function AutoCompleteSearchService_Factory(t) {
          return new (t || AutoCompleteSearchService)(_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_angular_common_http__WEBPACK_IMPORTED_MODULE_2__.HttpClient), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_angular_core__WEBPACK_IMPORTED_MODULE_4__.PLATFORM_ID), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_windowRef_service__WEBPACK_IMPORTED_MODULE_0__.GlobalRef), _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵinject"](_storage_service__WEBPACK_IMPORTED_MODULE_1__.LocalStorageService));
        };

        AutoCompleteSearchService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjectable"]({
          token: AutoCompleteSearchService,
          factory: function factory(t) {
            return AutoCompleteSearchService.ɵfac(t);
          }
        });

        (function () {
          (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](AutoCompleteSearchService, [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Injectable
          }], function () {
            return [{
              type: _angular_common_http__WEBPACK_IMPORTED_MODULE_2__.HttpClient
            }, {
              type: Object,
              decorators: [{
                type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.Inject,
                args: [_angular_core__WEBPACK_IMPORTED_MODULE_4__.PLATFORM_ID]
              }]
            }, {
              type: _windowRef_service__WEBPACK_IMPORTED_MODULE_0__.GlobalRef
            }, {
              type: _storage_service__WEBPACK_IMPORTED_MODULE_1__.LocalStorageService
            }];
          }, null);
        })();

        return AutoCompleteSearchService;
      }(); //# sourceMappingURL=auto-complete.service.js.map

      /***/

    },

    /***/
    73070: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "NgxGeoautocompleteModule": function NgxGeoautocompleteModule() {
          return (
            /* reexport safe */
            _ngx_geoautocomplete_module__WEBPACK_IMPORTED_MODULE_0__.NgxGeoautocompleteModule
          );
        },

        /* harmony export */
        "AutoCompleteComponent": function AutoCompleteComponent() {
          return (
            /* reexport safe */
            _auto_complete_component__WEBPACK_IMPORTED_MODULE_1__.AutoCompleteComponent
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _ngx_geoautocomplete_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./ngx-geoautocomplete.module */
      78641);
      /* harmony import */


      var _auto_complete_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./auto-complete.component */
      48482); //# sourceMappingURL=index.js.map

      /***/

    },

    /***/
    78641: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "NgxGeoautocompleteModule": function NgxGeoautocompleteModule() {
          return (
            /* binding */
            _NgxGeoautocompleteModule
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(
      /*! @angular/core */
      37716);
      /* harmony import */


      var _angular_common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(
      /*! @angular/common */
      38583);
      /* harmony import */


      var _angular_common_http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(
      /*! @angular/common/http */
      91841);
      /* harmony import */


      var _angular_forms__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(
      /*! @angular/forms */
      3679);
      /* harmony import */


      var _auto_complete_component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! ./auto-complete.component */
      48482);
      /* harmony import */


      var _auto_complete_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(
      /*! ./auto-complete.service */
      16674);
      /* harmony import */


      var _storage_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(
      /*! ./storage.service */
      32098);
      /* harmony import */


      var _windowRef_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(
      /*! ./windowRef.service */
      56313);

      var _NgxGeoautocompleteModule = function () {
        function NgxGeoautocompleteModule() {}

        NgxGeoautocompleteModule.forRoot = function () {
          return {
            ngModule: NgxGeoautocompleteModule
          };
        };

        NgxGeoautocompleteModule.ɵfac = function NgxGeoautocompleteModule_Factory(t) {
          return new (t || NgxGeoautocompleteModule)();
        };

        NgxGeoautocompleteModule.ɵmod = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineNgModule"]({
          type: NgxGeoautocompleteModule
        });
        NgxGeoautocompleteModule.ɵinj = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵdefineInjector"]({
          providers: [{
            provide: _windowRef_service__WEBPACK_IMPORTED_MODULE_3__.GlobalRef,
            useClass: _windowRef_service__WEBPACK_IMPORTED_MODULE_3__.BrowserGlobalRef
          }, _auto_complete_service__WEBPACK_IMPORTED_MODULE_1__.AutoCompleteSearchService, _storage_service__WEBPACK_IMPORTED_MODULE_2__.LocalStorageService],
          imports: [[_angular_common__WEBPACK_IMPORTED_MODULE_5__.CommonModule, _angular_common_http__WEBPACK_IMPORTED_MODULE_6__.HttpClientModule, _angular_forms__WEBPACK_IMPORTED_MODULE_7__.FormsModule]]
        });

        (function () {
          (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵsetClassMetadata"](NgxGeoautocompleteModule, [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_4__.NgModule,
            args: [{
              declarations: [_auto_complete_component__WEBPACK_IMPORTED_MODULE_0__.AutoCompleteComponent],
              imports: [_angular_common__WEBPACK_IMPORTED_MODULE_5__.CommonModule, _angular_common_http__WEBPACK_IMPORTED_MODULE_6__.HttpClientModule, _angular_forms__WEBPACK_IMPORTED_MODULE_7__.FormsModule],
              exports: [_auto_complete_component__WEBPACK_IMPORTED_MODULE_0__.AutoCompleteComponent],
              providers: [{
                provide: _windowRef_service__WEBPACK_IMPORTED_MODULE_3__.GlobalRef,
                useClass: _windowRef_service__WEBPACK_IMPORTED_MODULE_3__.BrowserGlobalRef
              }, _auto_complete_service__WEBPACK_IMPORTED_MODULE_1__.AutoCompleteSearchService, _storage_service__WEBPACK_IMPORTED_MODULE_2__.LocalStorageService]
            }]
          }], function () {
            return [];
          }, null);
        })();

        (function () {
          (typeof ngJitMode === "undefined" || ngJitMode) && _angular_core__WEBPACK_IMPORTED_MODULE_4__["ɵɵsetNgModuleScope"](NgxGeoautocompleteModule, {
            declarations: function declarations() {
              return [_auto_complete_component__WEBPACK_IMPORTED_MODULE_0__.AutoCompleteComponent];
            },
            imports: function imports() {
              return [_angular_common__WEBPACK_IMPORTED_MODULE_5__.CommonModule, _angular_common_http__WEBPACK_IMPORTED_MODULE_6__.HttpClientModule, _angular_forms__WEBPACK_IMPORTED_MODULE_7__.FormsModule];
            },
            exports: function exports() {
              return [_auto_complete_component__WEBPACK_IMPORTED_MODULE_0__.AutoCompleteComponent];
            }
          });
        })();

        return NgxGeoautocompleteModule;
      }(); //# sourceMappingURL=ngx-geoautocomplete.module.js.map

      /***/

    },

    /***/
    32098: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "LocalStorageService": function LocalStorageService() {
          return (
            /* binding */
            _LocalStorageService
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      37716);

      var _LocalStorageService = function () {
        function LocalStorageService() {}

        LocalStorageService.prototype.setItem = function (key, value) {
          localStorage.setItem(key, value);
        };

        LocalStorageService.prototype.getItem = function (key) {
          return localStorage.getItem(key);
        };

        LocalStorageService.prototype.removeItem = function (key) {
          localStorage.removeItem(key);
        };

        LocalStorageService.ɵfac = function LocalStorageService_Factory(t) {
          return new (t || LocalStorageService)();
        };

        LocalStorageService.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: LocalStorageService,
          factory: function factory(t) {
            return LocalStorageService.ɵfac(t);
          }
        });

        (function () {
          (typeof ngDevMode === "undefined" || ngDevMode) && _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵsetClassMetadata"](LocalStorageService, [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.Injectable
          }], function () {
            return [];
          }, null);
        })();

        return LocalStorageService;
      }(); //# sourceMappingURL=storage.service.js.map

      /***/

    },

    /***/
    56313: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "GlobalRef": function GlobalRef() {
          return (
            /* binding */
            _GlobalRef
          );
        },

        /* harmony export */
        "BrowserGlobalRef": function BrowserGlobalRef() {
          return (
            /* binding */
            _BrowserGlobalRef
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @angular/core */
      37716);

      var __extends = undefined && undefined.__extends || function () {
        var extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function (d, b) {
          d.__proto__ = b;
        } || function (d, b) {
          for (var p in b) {
            if (b.hasOwnProperty(p)) d[p] = b[p];
          }
        };

        return function (d, b) {
          extendStatics(d, b);

          function __() {
            this.constructor = d;
          }

          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();

      var _GlobalRef = function () {
        function GlobalRef() {}

        return GlobalRef;
      }();

      var _BrowserGlobalRef = function (_super) {
        __extends(BrowserGlobalRef, _super);

        function BrowserGlobalRef() {
          return _super !== null && _super.apply(this, arguments) || this;
        }

        Object.defineProperty(BrowserGlobalRef.prototype, "nativeGlobal", {
          get: function get() {
            return window;
          },
          enumerable: true,
          configurable: true
        });

        BrowserGlobalRef.ɵfac = /*@__PURE__*/function () {
          var ɵBrowserGlobalRef_BaseFactory;
          return function BrowserGlobalRef_Factory(t) {
            return (ɵBrowserGlobalRef_BaseFactory || (ɵBrowserGlobalRef_BaseFactory = _angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵgetInheritedFactory"](BrowserGlobalRef)))(t || BrowserGlobalRef);
          };
        }();

        BrowserGlobalRef.ɵprov = /*@__PURE__*/_angular_core__WEBPACK_IMPORTED_MODULE_0__["ɵɵdefineInjectable"]({
          token: BrowserGlobalRef,
          factory: function factory(t) {
            return BrowserGlobalRef.ɵfac(t);
          }
        });
        return BrowserGlobalRef;
      }(_GlobalRef); //# sourceMappingURL=windowRef.service.js.map

      /***/

    }
  }]);
})();
//# sourceMappingURL=default-node_modules_ngx-geoautocomplete___ivy_ngcc___index_js-es5.js.map