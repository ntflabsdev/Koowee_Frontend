(function () {
  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

  function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

  function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

  function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

  function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

  function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

  function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

  function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

  function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

  (self["webpackChunkkoowee"] = self["webpackChunkkoowee"] || []).push([["node_modules_capacitor_filesystem_dist_esm_web_js"], {
    /***/
    85143: function _(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */


      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */
        "FilesystemWeb": function FilesystemWeb() {
          return (
            /* binding */
            _FilesystemWeb
          );
        }
        /* harmony export */

      });
      /* harmony import */


      var _capacitor_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(
      /*! @capacitor/core */
      68384);

      var _FilesystemWeb = /*#__PURE__*/function (_capacitor_core__WEBP) {
        _inherits(_FilesystemWeb, _capacitor_core__WEBP);

        var _super = _createSuper(_FilesystemWeb);

        function _FilesystemWeb() {
          var _this;

          _classCallCheck(this, _FilesystemWeb);

          _this = _super.apply(this, arguments);
          _this.DB_VERSION = 1;
          _this.DB_NAME = 'Disc';
          _this._writeCmds = ['add', 'put', 'delete'];
          return _this;
        }

        _createClass(_FilesystemWeb, [{
          key: "initDb",
          value: function () {
            var _initDb = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
              var _this2 = this;

              return regeneratorRuntime.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (!(this._db !== undefined)) {
                        _context.next = 2;
                        break;
                      }

                      return _context.abrupt("return", this._db);

                    case 2:
                      if ('indexedDB' in window) {
                        _context.next = 4;
                        break;
                      }

                      throw this.unavailable("This browser doesn't support IndexedDB");

                    case 4:
                      return _context.abrupt("return", new Promise(function (resolve, reject) {
                        var request = indexedDB.open(_this2.DB_NAME, _this2.DB_VERSION);
                        request.onupgradeneeded = _FilesystemWeb.doUpgrade;

                        request.onsuccess = function () {
                          _this2._db = request.result;
                          resolve(request.result);
                        };

                        request.onerror = function () {
                          return reject(request.error);
                        };

                        request.onblocked = function () {
                          console.warn('db blocked');
                        };
                      }));

                    case 5:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this);
            }));

            function initDb() {
              return _initDb.apply(this, arguments);
            }

            return initDb;
          }()
        }, {
          key: "dbRequest",
          value: function () {
            var _dbRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(cmd, args) {
              var readFlag;
              return regeneratorRuntime.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';
                      return _context2.abrupt("return", this.initDb().then(function (conn) {
                        return new Promise(function (resolve, reject) {
                          var tx = conn.transaction(['FileStorage'], readFlag);
                          var store = tx.objectStore('FileStorage');
                          var req = store[cmd].apply(store, _toConsumableArray(args));

                          req.onsuccess = function () {
                            return resolve(req.result);
                          };

                          req.onerror = function () {
                            return reject(req.error);
                          };
                        });
                      }));

                    case 2:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this);
            }));

            function dbRequest(_x, _x2) {
              return _dbRequest.apply(this, arguments);
            }

            return dbRequest;
          }()
        }, {
          key: "dbIndexRequest",
          value: function () {
            var _dbIndexRequest = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(indexName, cmd, args) {
              var readFlag;
              return regeneratorRuntime.wrap(function _callee3$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      readFlag = this._writeCmds.indexOf(cmd) !== -1 ? 'readwrite' : 'readonly';
                      return _context3.abrupt("return", this.initDb().then(function (conn) {
                        return new Promise(function (resolve, reject) {
                          var tx = conn.transaction(['FileStorage'], readFlag);
                          var store = tx.objectStore('FileStorage');
                          var index = store.index(indexName);
                          var req = index[cmd].apply(index, _toConsumableArray(args));

                          req.onsuccess = function () {
                            return resolve(req.result);
                          };

                          req.onerror = function () {
                            return reject(req.error);
                          };
                        });
                      }));

                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, _callee3, this);
            }));

            function dbIndexRequest(_x3, _x4, _x5) {
              return _dbIndexRequest.apply(this, arguments);
            }

            return dbIndexRequest;
          }()
        }, {
          key: "getPath",
          value: function getPath(directory, uriPath) {
            var cleanedUriPath = uriPath !== undefined ? uriPath.replace(/^[/]+|[/]+$/g, '') : '';
            var fsPath = '';
            if (directory !== undefined) fsPath += '/' + directory;
            if (uriPath !== '') fsPath += '/' + cleanedUriPath;
            return fsPath;
          }
        }, {
          key: "clear",
          value: function () {
            var _clear = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
              var conn, tx, store;
              return regeneratorRuntime.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      _context4.next = 2;
                      return this.initDb();

                    case 2:
                      conn = _context4.sent;
                      tx = conn.transaction(['FileStorage'], 'readwrite');
                      store = tx.objectStore('FileStorage');
                      store.clear();

                    case 6:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function clear() {
              return _clear.apply(this, arguments);
            }

            return clear;
          }()
          /**
           * Read a file from disk
           * @param options options for the file read
           * @return a promise that resolves with the read file data result
           */

        }, {
          key: "readFile",
          value: function () {
            var _readFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(options) {
              var path, entry;
              return regeneratorRuntime.wrap(function _callee5$(_context5) {
                while (1) {
                  switch (_context5.prev = _context5.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path); // const encoding = options.encoding;

                      _context5.next = 3;
                      return this.dbRequest('get', [path]);

                    case 3:
                      entry = _context5.sent;

                      if (!(entry === undefined)) {
                        _context5.next = 6;
                        break;
                      }

                      throw Error('File does not exist.');

                    case 6:
                      return _context5.abrupt("return", {
                        data: entry.content ? entry.content : ''
                      });

                    case 7:
                    case "end":
                      return _context5.stop();
                  }
                }
              }, _callee5, this);
            }));

            function readFile(_x6) {
              return _readFile.apply(this, arguments);
            }

            return readFile;
          }()
          /**
           * Write a file to disk in the specified location on device
           * @param options options for the file write
           * @return a promise that resolves with the file write result
           */

        }, {
          key: "writeFile",
          value: function () {
            var _writeFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(options) {
              var path, data, doRecursive, occupiedEntry, encoding, parentPath, parentEntry, subDirIndex, parentArgPath, now, pathObj;
              return regeneratorRuntime.wrap(function _callee6$(_context6) {
                while (1) {
                  switch (_context6.prev = _context6.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path);
                      data = options.data;
                      doRecursive = options.recursive;
                      _context6.next = 5;
                      return this.dbRequest('get', [path]);

                    case 5:
                      occupiedEntry = _context6.sent;

                      if (!(occupiedEntry && occupiedEntry.type === 'directory')) {
                        _context6.next = 8;
                        break;
                      }

                      throw 'The supplied path is a directory.';

                    case 8:
                      encoding = options.encoding;
                      parentPath = path.substr(0, path.lastIndexOf('/'));
                      _context6.next = 12;
                      return this.dbRequest('get', [parentPath]);

                    case 12:
                      parentEntry = _context6.sent;

                      if (!(parentEntry === undefined)) {
                        _context6.next = 19;
                        break;
                      }

                      subDirIndex = parentPath.indexOf('/', 1);

                      if (!(subDirIndex !== -1)) {
                        _context6.next = 19;
                        break;
                      }

                      parentArgPath = parentPath.substr(subDirIndex);
                      _context6.next = 19;
                      return this.mkdir({
                        path: parentArgPath,
                        directory: options.directory,
                        recursive: doRecursive
                      });

                    case 19:
                      now = Date.now();
                      pathObj = {
                        path: path,
                        folder: parentPath,
                        type: 'file',
                        size: data.length,
                        ctime: now,
                        mtime: now,
                        content: !encoding && data.indexOf(',') >= 0 ? data.split(',')[1] : data
                      };
                      _context6.next = 23;
                      return this.dbRequest('put', [pathObj]);

                    case 23:
                      return _context6.abrupt("return", {
                        uri: pathObj.path
                      });

                    case 24:
                    case "end":
                      return _context6.stop();
                  }
                }
              }, _callee6, this);
            }));

            function writeFile(_x7) {
              return _writeFile.apply(this, arguments);
            }

            return writeFile;
          }()
          /**
           * Append to a file on disk in the specified location on device
           * @param options options for the file append
           * @return a promise that resolves with the file write result
           */

        }, {
          key: "appendFile",
          value: function () {
            var _appendFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7(options) {
              var path, data, parentPath, now, ctime, occupiedEntry, parentEntry, subDirIndex, parentArgPath, pathObj;
              return regeneratorRuntime.wrap(function _callee7$(_context7) {
                while (1) {
                  switch (_context7.prev = _context7.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path);
                      data = options.data; // const encoding = options.encoding;

                      parentPath = path.substr(0, path.lastIndexOf('/'));
                      now = Date.now();
                      ctime = now;
                      _context7.next = 7;
                      return this.dbRequest('get', [path]);

                    case 7:
                      occupiedEntry = _context7.sent;

                      if (!(occupiedEntry && occupiedEntry.type === 'directory')) {
                        _context7.next = 10;
                        break;
                      }

                      throw 'The supplied path is a directory.';

                    case 10:
                      _context7.next = 12;
                      return this.dbRequest('get', [parentPath]);

                    case 12:
                      parentEntry = _context7.sent;

                      if (!(parentEntry === undefined)) {
                        _context7.next = 19;
                        break;
                      }

                      subDirIndex = parentPath.indexOf('/', 1);

                      if (!(subDirIndex !== -1)) {
                        _context7.next = 19;
                        break;
                      }

                      parentArgPath = parentPath.substr(subDirIndex);
                      _context7.next = 19;
                      return this.mkdir({
                        path: parentArgPath,
                        directory: options.directory,
                        recursive: true
                      });

                    case 19:
                      if (occupiedEntry !== undefined) {
                        data = occupiedEntry.content + data;
                        ctime = occupiedEntry.ctime;
                      }

                      pathObj = {
                        path: path,
                        folder: parentPath,
                        type: 'file',
                        size: data.length,
                        ctime: ctime,
                        mtime: now,
                        content: data
                      };
                      _context7.next = 23;
                      return this.dbRequest('put', [pathObj]);

                    case 23:
                    case "end":
                      return _context7.stop();
                  }
                }
              }, _callee7, this);
            }));

            function appendFile(_x8) {
              return _appendFile.apply(this, arguments);
            }

            return appendFile;
          }()
          /**
           * Delete a file from disk
           * @param options options for the file delete
           * @return a promise that resolves with the deleted file data result
           */

        }, {
          key: "deleteFile",
          value: function () {
            var _deleteFile = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(options) {
              var path, entry, entries;
              return regeneratorRuntime.wrap(function _callee8$(_context8) {
                while (1) {
                  switch (_context8.prev = _context8.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path);
                      _context8.next = 3;
                      return this.dbRequest('get', [path]);

                    case 3:
                      entry = _context8.sent;

                      if (!(entry === undefined)) {
                        _context8.next = 6;
                        break;
                      }

                      throw Error('File does not exist.');

                    case 6:
                      _context8.next = 8;
                      return this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);

                    case 8:
                      entries = _context8.sent;

                      if (!(entries.length !== 0)) {
                        _context8.next = 11;
                        break;
                      }

                      throw Error('Folder is not empty.');

                    case 11:
                      _context8.next = 13;
                      return this.dbRequest('delete', [path]);

                    case 13:
                    case "end":
                      return _context8.stop();
                  }
                }
              }, _callee8, this);
            }));

            function deleteFile(_x9) {
              return _deleteFile.apply(this, arguments);
            }

            return deleteFile;
          }()
          /**
           * Create a directory.
           * @param options options for the mkdir
           * @return a promise that resolves with the mkdir result
           */

        }, {
          key: "mkdir",
          value: function () {
            var _mkdir = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(options) {
              var path, doRecursive, parentPath, depth, parentEntry, occupiedEntry, parentArgPath, now, pathObj;
              return regeneratorRuntime.wrap(function _callee9$(_context9) {
                while (1) {
                  switch (_context9.prev = _context9.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path);
                      doRecursive = options.recursive;
                      parentPath = path.substr(0, path.lastIndexOf('/'));
                      depth = (path.match(/\//g) || []).length;
                      _context9.next = 6;
                      return this.dbRequest('get', [parentPath]);

                    case 6:
                      parentEntry = _context9.sent;
                      _context9.next = 9;
                      return this.dbRequest('get', [path]);

                    case 9:
                      occupiedEntry = _context9.sent;

                      if (!(depth === 1)) {
                        _context9.next = 12;
                        break;
                      }

                      throw Error('Cannot create Root directory');

                    case 12:
                      if (!(occupiedEntry !== undefined)) {
                        _context9.next = 14;
                        break;
                      }

                      throw Error('Current directory does already exist.');

                    case 14:
                      if (!(!doRecursive && depth !== 2 && parentEntry === undefined)) {
                        _context9.next = 16;
                        break;
                      }

                      throw Error('Parent directory must exist');

                    case 16:
                      if (!(doRecursive && depth !== 2 && parentEntry === undefined)) {
                        _context9.next = 20;
                        break;
                      }

                      parentArgPath = parentPath.substr(parentPath.indexOf('/', 1));
                      _context9.next = 20;
                      return this.mkdir({
                        path: parentArgPath,
                        directory: options.directory,
                        recursive: doRecursive
                      });

                    case 20:
                      now = Date.now();
                      pathObj = {
                        path: path,
                        folder: parentPath,
                        type: 'directory',
                        size: 0,
                        ctime: now,
                        mtime: now
                      };
                      _context9.next = 24;
                      return this.dbRequest('put', [pathObj]);

                    case 24:
                    case "end":
                      return _context9.stop();
                  }
                }
              }, _callee9, this);
            }));

            function mkdir(_x10) {
              return _mkdir.apply(this, arguments);
            }

            return mkdir;
          }()
          /**
           * Remove a directory
           * @param options the options for the directory remove
           */

        }, {
          key: "rmdir",
          value: function () {
            var _rmdir = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(options) {
              var path, directory, recursive, fullPath, entry, readDirResult, _iterator, _step, _entry, entryPath, entryObj;

              return regeneratorRuntime.wrap(function _callee10$(_context10) {
                while (1) {
                  switch (_context10.prev = _context10.next) {
                    case 0:
                      path = options.path, directory = options.directory, recursive = options.recursive;
                      fullPath = this.getPath(directory, path);
                      _context10.next = 4;
                      return this.dbRequest('get', [fullPath]);

                    case 4:
                      entry = _context10.sent;

                      if (!(entry === undefined)) {
                        _context10.next = 7;
                        break;
                      }

                      throw Error('Folder does not exist.');

                    case 7:
                      if (!(entry.type !== 'directory')) {
                        _context10.next = 9;
                        break;
                      }

                      throw Error('Requested path is not a directory');

                    case 9:
                      _context10.next = 11;
                      return this.readdir({
                        path: path,
                        directory: directory
                      });

                    case 11:
                      readDirResult = _context10.sent;

                      if (!(readDirResult.files.length !== 0 && !recursive)) {
                        _context10.next = 14;
                        break;
                      }

                      throw Error('Folder is not empty');

                    case 14:
                      _iterator = _createForOfIteratorHelper(readDirResult.files);
                      _context10.prev = 15;

                      _iterator.s();

                    case 17:
                      if ((_step = _iterator.n()).done) {
                        _context10.next = 32;
                        break;
                      }

                      _entry = _step.value;
                      entryPath = "".concat(path, "/").concat(_entry);
                      _context10.next = 22;
                      return this.stat({
                        path: entryPath,
                        directory: directory
                      });

                    case 22:
                      entryObj = _context10.sent;

                      if (!(entryObj.type === 'file')) {
                        _context10.next = 28;
                        break;
                      }

                      _context10.next = 26;
                      return this.deleteFile({
                        path: entryPath,
                        directory: directory
                      });

                    case 26:
                      _context10.next = 30;
                      break;

                    case 28:
                      _context10.next = 30;
                      return this.rmdir({
                        path: entryPath,
                        directory: directory,
                        recursive: recursive
                      });

                    case 30:
                      _context10.next = 17;
                      break;

                    case 32:
                      _context10.next = 37;
                      break;

                    case 34:
                      _context10.prev = 34;
                      _context10.t0 = _context10["catch"](15);

                      _iterator.e(_context10.t0);

                    case 37:
                      _context10.prev = 37;

                      _iterator.f();

                      return _context10.finish(37);

                    case 40:
                      _context10.next = 42;
                      return this.dbRequest('delete', [fullPath]);

                    case 42:
                    case "end":
                      return _context10.stop();
                  }
                }
              }, _callee10, this, [[15, 34, 37, 40]]);
            }));

            function rmdir(_x11) {
              return _rmdir.apply(this, arguments);
            }

            return rmdir;
          }()
          /**
           * Return a list of files from the directory (not recursive)
           * @param options the options for the readdir operation
           * @return a promise that resolves with the readdir directory listing result
           */

        }, {
          key: "readdir",
          value: function () {
            var _readdir = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(options) {
              var path, entry, entries, names;
              return regeneratorRuntime.wrap(function _callee11$(_context11) {
                while (1) {
                  switch (_context11.prev = _context11.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path);
                      _context11.next = 3;
                      return this.dbRequest('get', [path]);

                    case 3:
                      entry = _context11.sent;

                      if (!(options.path !== '' && entry === undefined)) {
                        _context11.next = 6;
                        break;
                      }

                      throw Error('Folder does not exist.');

                    case 6:
                      _context11.next = 8;
                      return this.dbIndexRequest('by_folder', 'getAllKeys', [IDBKeyRange.only(path)]);

                    case 8:
                      entries = _context11.sent;
                      names = entries.map(function (e) {
                        return e.substring(path.length + 1);
                      });
                      return _context11.abrupt("return", {
                        files: names
                      });

                    case 11:
                    case "end":
                      return _context11.stop();
                  }
                }
              }, _callee11, this);
            }));

            function readdir(_x12) {
              return _readdir.apply(this, arguments);
            }

            return readdir;
          }()
          /**
           * Return full File URI for a path and directory
           * @param options the options for the stat operation
           * @return a promise that resolves with the file stat result
           */

        }, {
          key: "getUri",
          value: function () {
            var _getUri = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12(options) {
              var path, entry;
              return regeneratorRuntime.wrap(function _callee12$(_context12) {
                while (1) {
                  switch (_context12.prev = _context12.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path);
                      _context12.next = 3;
                      return this.dbRequest('get', [path]);

                    case 3:
                      entry = _context12.sent;

                      if (!(entry === undefined)) {
                        _context12.next = 8;
                        break;
                      }

                      _context12.next = 7;
                      return this.dbRequest('get', [path + '/']);

                    case 7:
                      entry = _context12.sent;

                    case 8:
                      return _context12.abrupt("return", {
                        uri: (entry === null || entry === void 0 ? void 0 : entry.path) || path
                      });

                    case 9:
                    case "end":
                      return _context12.stop();
                  }
                }
              }, _callee12, this);
            }));

            function getUri(_x13) {
              return _getUri.apply(this, arguments);
            }

            return getUri;
          }()
          /**
           * Return data about a file
           * @param options the options for the stat operation
           * @return a promise that resolves with the file stat result
           */

        }, {
          key: "stat",
          value: function () {
            var _stat = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(options) {
              var path, entry;
              return regeneratorRuntime.wrap(function _callee13$(_context13) {
                while (1) {
                  switch (_context13.prev = _context13.next) {
                    case 0:
                      path = this.getPath(options.directory, options.path);
                      _context13.next = 3;
                      return this.dbRequest('get', [path]);

                    case 3:
                      entry = _context13.sent;

                      if (!(entry === undefined)) {
                        _context13.next = 8;
                        break;
                      }

                      _context13.next = 7;
                      return this.dbRequest('get', [path + '/']);

                    case 7:
                      entry = _context13.sent;

                    case 8:
                      if (!(entry === undefined)) {
                        _context13.next = 10;
                        break;
                      }

                      throw Error('Entry does not exist.');

                    case 10:
                      return _context13.abrupt("return", {
                        type: entry.type,
                        size: entry.size,
                        ctime: entry.ctime,
                        mtime: entry.mtime,
                        uri: entry.path
                      });

                    case 11:
                    case "end":
                      return _context13.stop();
                  }
                }
              }, _callee13, this);
            }));

            function stat(_x14) {
              return _stat.apply(this, arguments);
            }

            return stat;
          }()
          /**
           * Rename a file or directory
           * @param options the options for the rename operation
           * @return a promise that resolves with the rename result
           */

        }, {
          key: "rename",
          value: function () {
            var _rename = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(options) {
              return regeneratorRuntime.wrap(function _callee14$(_context14) {
                while (1) {
                  switch (_context14.prev = _context14.next) {
                    case 0:
                      return _context14.abrupt("return", this._copy(options, true));

                    case 1:
                    case "end":
                      return _context14.stop();
                  }
                }
              }, _callee14, this);
            }));

            function rename(_x15) {
              return _rename.apply(this, arguments);
            }

            return rename;
          }()
          /**
           * Copy a file or directory
           * @param options the options for the copy operation
           * @return a promise that resolves with the copy result
           */

        }, {
          key: "copy",
          value: function () {
            var _copy2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(options) {
              return regeneratorRuntime.wrap(function _callee15$(_context15) {
                while (1) {
                  switch (_context15.prev = _context15.next) {
                    case 0:
                      return _context15.abrupt("return", this._copy(options, false));

                    case 1:
                    case "end":
                      return _context15.stop();
                  }
                }
              }, _callee15, this);
            }));

            function copy(_x16) {
              return _copy2.apply(this, arguments);
            }

            return copy;
          }()
        }, {
          key: "requestPermissions",
          value: function () {
            var _requestPermissions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16() {
              return regeneratorRuntime.wrap(function _callee16$(_context16) {
                while (1) {
                  switch (_context16.prev = _context16.next) {
                    case 0:
                      return _context16.abrupt("return", {
                        publicStorage: 'granted'
                      });

                    case 1:
                    case "end":
                      return _context16.stop();
                  }
                }
              }, _callee16);
            }));

            function requestPermissions() {
              return _requestPermissions.apply(this, arguments);
            }

            return requestPermissions;
          }()
        }, {
          key: "checkPermissions",
          value: function () {
            var _checkPermissions = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee17() {
              return regeneratorRuntime.wrap(function _callee17$(_context17) {
                while (1) {
                  switch (_context17.prev = _context17.next) {
                    case 0:
                      return _context17.abrupt("return", {
                        publicStorage: 'granted'
                      });

                    case 1:
                    case "end":
                      return _context17.stop();
                  }
                }
              }, _callee17);
            }));

            function checkPermissions() {
              return _checkPermissions.apply(this, arguments);
            }

            return checkPermissions;
          }()
          /**
           * Function that can perform a copy or a rename
           * @param options the options for the rename operation
           * @param doRename whether to perform a rename or copy operation
           * @return a promise that resolves with the result
           */

        }, {
          key: "_copy",
          value: function () {
            var _copy3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee19(options) {
              var _this3 = this;

              var doRename,
                  toDirectory,
                  to,
                  from,
                  fromDirectory,
                  fromPath,
                  toPath,
                  toObj,
                  toPathComponents,
                  _toPath,
                  toParentDirectory,
                  fromObj,
                  updateTime,
                  ctime,
                  file,
                  contents,
                  _iterator2,
                  _step2,
                  filename,
                  _args19 = arguments;

              return regeneratorRuntime.wrap(function _callee19$(_context19) {
                while (1) {
                  switch (_context19.prev = _context19.next) {
                    case 0:
                      doRename = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : false;
                      toDirectory = options.toDirectory;
                      to = options.to, from = options.from, fromDirectory = options.directory;

                      if (!(!to || !from)) {
                        _context19.next = 5;
                        break;
                      }

                      throw Error('Both to and from must be provided');

                    case 5:
                      // If no "to" directory is provided, use the "from" directory
                      if (!toDirectory) {
                        toDirectory = fromDirectory;
                      }

                      fromPath = this.getPath(fromDirectory, from);
                      toPath = this.getPath(toDirectory, to); // Test that the "to" and "from" locations are different

                      if (!(fromPath === toPath)) {
                        _context19.next = 10;
                        break;
                      }

                      return _context19.abrupt("return");

                    case 10:
                      if (!toPath.startsWith(fromPath)) {
                        _context19.next = 12;
                        break;
                      }

                      throw Error('To path cannot contain the from path');

                    case 12:
                      _context19.prev = 12;
                      _context19.next = 15;
                      return this.stat({
                        path: to,
                        directory: toDirectory
                      });

                    case 15:
                      toObj = _context19.sent;
                      _context19.next = 29;
                      break;

                    case 18:
                      _context19.prev = 18;
                      _context19.t0 = _context19["catch"](12);
                      // To location does not exist, ensure the directory containing "to" location exists and is a directory
                      toPathComponents = to.split('/');
                      toPathComponents.pop();
                      _toPath = toPathComponents.join('/'); // Check the containing directory of the "to" location exists

                      if (!(toPathComponents.length > 0)) {
                        _context19.next = 29;
                        break;
                      }

                      _context19.next = 26;
                      return this.stat({
                        path: _toPath,
                        directory: toDirectory
                      });

                    case 26:
                      toParentDirectory = _context19.sent;

                      if (!(toParentDirectory.type !== 'directory')) {
                        _context19.next = 29;
                        break;
                      }

                      throw new Error('Parent directory of the to path is a file');

                    case 29:
                      if (!(toObj && toObj.type === 'directory')) {
                        _context19.next = 31;
                        break;
                      }

                      throw new Error('Cannot overwrite a directory with a file');

                    case 31:
                      _context19.next = 33;
                      return this.stat({
                        path: from,
                        directory: fromDirectory
                      });

                    case 33:
                      fromObj = _context19.sent;

                      // Set the mtime/ctime of the supplied path
                      updateTime = /*#__PURE__*/function () {
                        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee18(path, ctime, mtime) {
                          var fullPath, entry;
                          return regeneratorRuntime.wrap(function _callee18$(_context18) {
                            while (1) {
                              switch (_context18.prev = _context18.next) {
                                case 0:
                                  fullPath = _this3.getPath(toDirectory, path);
                                  _context18.next = 3;
                                  return _this3.dbRequest('get', [fullPath]);

                                case 3:
                                  entry = _context18.sent;
                                  entry.ctime = ctime;
                                  entry.mtime = mtime;
                                  _context18.next = 8;
                                  return _this3.dbRequest('put', [entry]);

                                case 8:
                                case "end":
                                  return _context18.stop();
                              }
                            }
                          }, _callee18);
                        }));

                        return function updateTime(_x18, _x19, _x20) {
                          return _ref.apply(this, arguments);
                        };
                      }();

                      ctime = fromObj.ctime ? fromObj.ctime : Date.now();
                      _context19.t1 = fromObj.type;
                      _context19.next = _context19.t1 === 'file' ? 39 : _context19.t1 === 'directory' ? 51 : 86;
                      break;

                    case 39:
                      _context19.next = 41;
                      return this.readFile({
                        path: from,
                        directory: fromDirectory
                      });

                    case 41:
                      file = _context19.sent;

                      if (!doRename) {
                        _context19.next = 45;
                        break;
                      }

                      _context19.next = 45;
                      return this.deleteFile({
                        path: from,
                        directory: fromDirectory
                      });

                    case 45:
                      _context19.next = 47;
                      return this.writeFile({
                        path: to,
                        directory: toDirectory,
                        data: file.data
                      });

                    case 47:
                      if (!doRename) {
                        _context19.next = 50;
                        break;
                      }

                      _context19.next = 50;
                      return updateTime(to, ctime, fromObj.mtime);

                    case 50:
                      return _context19.abrupt("return");

                    case 51:
                      if (!toObj) {
                        _context19.next = 53;
                        break;
                      }

                      throw Error('Cannot move a directory over an existing object');

                    case 53:
                      _context19.prev = 53;
                      _context19.next = 56;
                      return this.mkdir({
                        path: to,
                        directory: toDirectory,
                        recursive: false
                      });

                    case 56:
                      if (!doRename) {
                        _context19.next = 59;
                        break;
                      }

                      _context19.next = 59;
                      return updateTime(to, ctime, fromObj.mtime);

                    case 59:
                      _context19.next = 63;
                      break;

                    case 61:
                      _context19.prev = 61;
                      _context19.t2 = _context19["catch"](53);

                    case 63:
                      _context19.next = 65;
                      return this.readdir({
                        path: from,
                        directory: fromDirectory
                      });

                    case 65:
                      contents = _context19.sent.files;
                      _iterator2 = _createForOfIteratorHelper(contents);
                      _context19.prev = 67;

                      _iterator2.s();

                    case 69:
                      if ((_step2 = _iterator2.n()).done) {
                        _context19.next = 75;
                        break;
                      }

                      filename = _step2.value;
                      _context19.next = 73;
                      return this._copy({
                        from: "".concat(from, "/").concat(filename),
                        to: "".concat(to, "/").concat(filename),
                        directory: fromDirectory,
                        toDirectory: toDirectory
                      }, doRename);

                    case 73:
                      _context19.next = 69;
                      break;

                    case 75:
                      _context19.next = 80;
                      break;

                    case 77:
                      _context19.prev = 77;
                      _context19.t3 = _context19["catch"](67);

                      _iterator2.e(_context19.t3);

                    case 80:
                      _context19.prev = 80;

                      _iterator2.f();

                      return _context19.finish(80);

                    case 83:
                      if (!doRename) {
                        _context19.next = 86;
                        break;
                      }

                      _context19.next = 86;
                      return this.rmdir({
                        path: from,
                        directory: fromDirectory
                      });

                    case 86:
                    case "end":
                      return _context19.stop();
                  }
                }
              }, _callee19, this, [[12, 18], [53, 61], [67, 77, 80, 83]]);
            }));

            function _copy(_x17) {
              return _copy3.apply(this, arguments);
            }

            return _copy;
          }()
        }], [{
          key: "doUpgrade",
          value: function doUpgrade(event) {
            var eventTarget = event.target;
            var db = eventTarget.result;

            switch (event.oldVersion) {
              case 0:
              case 1:
              default:
                {
                  if (db.objectStoreNames.contains('FileStorage')) {
                    db.deleteObjectStore('FileStorage');
                  }

                  var store = db.createObjectStore('FileStorage', {
                    keyPath: 'path'
                  });
                  store.createIndex('by_folder', 'folder');
                }
            }
          }
        }]);

        return _FilesystemWeb;
      }(_capacitor_core__WEBPACK_IMPORTED_MODULE_0__.WebPlugin);

      _FilesystemWeb._debug = true; //# sourceMappingURL=web.js.map

      /***/
    }
  }]);
})();
//# sourceMappingURL=node_modules_capacitor_filesystem_dist_esm_web_js-es5.js.map